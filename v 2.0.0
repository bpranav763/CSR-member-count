from dotenv import load_dotenv
load_dotenv()

import discord
import aiohttp
import asyncio
import datetime
import re
import os
import json
import random
from discord.ext import commands, tasks
from discord import ui
from bs4 import BeautifulSoup
from youtube_transcript_api import YouTubeTranscriptApi
from googleapiclient.discovery import build

# --- CONFIGURATION ---
TOKEN = os.getenv('DISCORD_BOT_TOKEN')
HF_TOKEN = os.getenv('HF_TOKEN')
YOUTUBE_API_KEY = os.getenv('YOUTUBE_API_KEY')  # Get from Google Cloud Console

if not TOKEN:
    raise ValueError("DISCORD_BOT_TOKEN environment variable is required!")

CHANNEL_ID = 1432803218919919666
GROUP_ID = '1003228779'
GUILD_IMAGE = 'https://tr.rbxcdn.com/180DAY-929c99c9ad05b139c8851f873606876e/150/150/Image/Webp/noFilter'
UPDATE_INTERVAL = 300
CSR_STAFF_ROLE_ID = 1430084386837102673
MODLOG_CHANNEL_ID = 1429402899649134664
DAILYCHECKS = 1433403158612279327
CSR_EMOJI = "<:CSR:1432804739447263333>"
MUTED_ROLE_ID = 1433893267816054844

# Verification settings
VERIFICATION_CHANNEL_ID = 1433909897749073931
HELP_CHANNEL_ID = 1434121366008889457
VERIFICATION_PENDING_ROLE_ID = 1425155127530225767
MEMBER_APPROVED_ROLE_ID = 1425144091762495631
VISITOR_ROLE_ID = 1433907795593531513

# Wiki & YouTube URLs
SBOR_WIKI_URL = "https://swordbloxonlinerebirth.fandom.com"
BLOXFRUITS_WIKI_URL = "https://blox-fruits.fandom.com"
YOUTUBE_CHANNEL_ID = "UC75x60utxCnFWRPDsUIdsWA"  # Extract from: https://www.youtube.com/@ChampionsOfShatteredRealm

BOT_VERSION = "3.0.0"
BOT_UPDATE = "ELITE: Wiki scraper, YouTube transcripts, smart AI, auto-updates every 24hrs"
BOT_AUTHOR = "kikusuka"
BOT_CREATED = "October 24, 2025"

conversation_memory = {}
MAX_MEMORY_PER_CHANNEL = 10

# --- DATA STORAGE PATHS ---
DATA_DIR = "data"
os.makedirs(DATA_DIR, exist_ok=True)

SBOR_WIKI_FILE = f"{DATA_DIR}/sbor_wiki.json"
BLOXFRUITS_WIKI_FILE = f"{DATA_DIR}/bloxfruits_wiki.json"
YOUTUBE_DATA_FILE = f"{DATA_DIR}/youtube_transcripts.json"
GUILD_FAQS_FILE = f"{DATA_DIR}/guild_faqs.json"
LAST_UPDATE_FILE = f"{DATA_DIR}/last_update.json"

# --- KNOWLEDGE BASE ---
def load_or_create_file(filepath, default_data):
    """Load JSON file or create with default data"""
    if os.path.exists(filepath):
        with open(filepath, 'r', encoding='utf-8') as f:
            return json.load(f)
    else:
        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(default_data, f, indent=2)
        return default_data

def save_json(filepath, data):
    """Save data to JSON file"""
    with open(filepath, 'w', encoding='utf-8') as f:
        json.dump(data, f, indent=2, ensure_ascii=False)

# Initialize data files
SBOR_WIKI_DATA = load_or_create_file(SBOR_WIKI_FILE, {"pages": {}, "last_update": None})
BLOXFRUITS_WIKI_DATA = load_or_create_file(BLOXFRUITS_WIKI_FILE, {"pages": {}, "last_update": None})
YOUTUBE_DATA = load_or_create_file(YOUTUBE_DATA_FILE, {"videos": {}, "last_update": None})
GUILD_FAQS = load_or_create_file(GUILD_FAQS_FILE, {
    "faqs": [
        {
            "id": 1,
            "question": "What is CSR?",
            "answer": "CSR = Champions of the Shattered Realm! We're a multi-game guild for Roblox, SBOR, Blox Fruits & more!",
            "keywords": ["what is csr", "about csr", "csr guild"]
        }
    ],
    "next_id": 2
})

# Casual responses
CASUAL_RESPONSES = {
    'greetings': ["Yo! What's good? üëã", "Hey hey! How's it going? üòä", "Sup! Need something?", 
                  "Hello there! Ready to game? üéÆ", "What's up! How can I help?", "Heyo! Welcome! üî•"],
    'thanks': ["No problem! Happy to help! üòä", "You're welcome! üéâ", "Anytime! That's what I'm here for!",
               "Glad I could help! üí™", "For sure! Let me know if you need more!", "NP! Hit me up if you need anything else!"],
    'goodbye': ["See ya! Have fun! üëã", "Later! Good luck out there! üéÆ", "Catch you later! Stay awesome!", "Peace out! ‚úåÔ∏è"]
}

# --- LOAD BAD WORDS ---
def load_bad_words(filepath="badwords.txt"):
    if not os.path.exists(filepath):
        with open(filepath, "w") as f:
            f.write("# Add bad words here, one per line\n")
        return set()
    
    with open(filepath, "r") as f:
        words = [line.strip().lower() for line in f if line.strip() and not line.startswith("#")]
    return set(words)

BAD_WORDS = load_bad_words()
BAD_WORDS_REGEX = re.compile(r"\b(" + "|".join(map(re.escape, BAD_WORDS)) + r")\b", re.IGNORECASE) if BAD_WORDS else None
CHAT_FILTER_ENABLED = True
AI_MODERATION_ENABLED = True

intents = discord.Intents.default()
intents.members = True
intents.message_content = True
bot = commands.Bot(command_prefix="/", intents=intents)

# --- WIKI SCRAPER ---
async def scrape_wiki_pages(wiki_base_url, wiki_name, old_pages=None):
    """Scrape all pages from a Fandom wiki, skip pages scraped <30 days ago, collect main image."""
    print(f"üï∑Ô∏è Scraping {wiki_name} wiki...")
    pages = dict(old_pages) if old_pages else {}

    try:
        all_pages_url = f"{wiki_base_url}/wiki/Special:AllPages"

        async with aiohttp.ClientSession() as session:
            async with session.get(all_pages_url, timeout=40) as response:
                if response.status != 200:
                    print(f"‚ùå Failed to fetch {wiki_name} pages list")
                    return pages

                html = await response.text()
                soup = BeautifulSoup(html, 'html.parser')

                page_links = soup.select('div.mw-allpages-body a')
                print(f"üìÑ Found {len(page_links)} pages in {wiki_name}")

                for i, link in enumerate(page_links):
                    title = link.get_text().strip().lower()
                    url = wiki_base_url + link['href']

                    if title in pages:
                        last_scraped = datetime.datetime.fromisoformat(pages[title]['scraped'])
                        if (datetime.datetime.utcnow() - last_scraped).days < 30:
                            if i % 50 == 0:
                                print(f"   Skipping '{title}' (scraped <30 days ago)")
                            continue

                    try:
                        async with session.get(url, timeout=25) as page_response:
                            if page_response.status == 200:
                                page_html = await page_response.text()
                                page_soup = BeautifulSoup(page_html, 'html.parser')

                                content_div = page_soup.find('div', {'class': 'mw-parser-output'})
                                if content_div:
                                    paragraphs = content_div.find_all('p', limit=5)
                                    content = ' '.join([p.get_text().strip() for p in paragraphs if p.get_text().strip()])
                                    img_url = None
                                    img_tag = content_div.find('img')
                                    if img_tag and img_tag.get('src'):
                                        img_url = img_tag['src']

                                    if content:
                                        pages[title] = {
                                            'title': link.get_text().strip(),
                                            'url': url,
                                            'content': content[:1000],
                                            'image': img_url,
                                            'scraped': datetime.datetime.utcnow().isoformat()
                                        }

                        if i % 50 == 0:
                            print(f"   Progress: {i}/{len(page_links)} pages processed...")

                        await asyncio.sleep(0.5)
                    except Exception as e:
                        print(f"   ‚ö†Ô∏è Failed to scrape '{title}': {e}")
                        continue

        print(f"‚úÖ Scraping complete for {wiki_name}! Total unique pages loaded: {len(pages)}")
    except Exception as e:
        print(f"‚ùå Wiki scraping error for {wiki_name}: {e}")

    return pages

# --- YOUTUBE SCRAPER ---
async def scrape_youtube_channel():
    """Scrape video transcripts from CSR YouTube channel"""
    print("üé• Scraping YouTube channel...")
    videos = {}
    
    if not YOUTUBE_API_KEY:
        print("‚ö†Ô∏è No YouTube API key - skipping YouTube scraping")
        return videos
    
    try:
        youtube = build('youtube', 'v3', developerKey=YOUTUBE_API_KEY)
        
        # Get channel uploads
        request = youtube.channels().list(
            part='contentDetails',
            id=YOUTUBE_CHANNEL_ID
        )
        response = request.execute()
        
        if not response['items']:
            print("‚ùå Channel not found")
            return videos
        
        uploads_playlist = response['items'][0]['contentDetails']['relatedPlaylists']['uploads']
        
        # Get videos from uploads playlist
        videos_request = youtube.playlistItems().list(
            part='snippet',
            playlistId=uploads_playlist,
            maxResults=50
        )
        videos_response = videos_request.execute()
        
        print(f"üìπ Found {len(videos_response['items'])} videos")
        
        for item in videos_response['items']:
            video_id = item['snippet']['resourceId']['videoId']
            video_title = item['snippet']['title']
            video_url = f"https://www.youtube.com/watch?v={video_id}"
            
            try:
                # Get transcript
                transcript_list = YouTubeTranscriptApi.get_transcript(video_id)
                transcript_text = ' '.join([t['text'] for t in transcript_list])
                
                videos[video_id] = {
                    'title': video_title,
                    'url': video_url,
                    'transcript': transcript_text[:2000],  # First 2000 chars
                    'scraped': datetime.datetime.utcnow().isoformat()
                }
                
                print(f"   ‚úÖ Got transcript for: {video_title}")
            except Exception as e:
                print(f"   ‚ö†Ô∏è No transcript for {video_title}: {e}")
                # Store video without transcript
                videos[video_id] = {
                    'title': video_title,
                    'url': video_url,
                    'transcript': None,
                    'scraped': datetime.datetime.utcnow().isoformat()
                }
        
        print(f"‚úÖ Scraped {len(videos)} videos")
    except Exception as e:
        print(f"‚ùå YouTube scraping error: {e}")
    
    return videos

# --- AUTO UPDATE TASK ---
@tasks.loop(hours=168)  # 168 hours = 7 days = 1 week
async def auto_update_data():
    """Update wiki and YouTube data once a week at 3 AM UTC (quietest time)"""
    # Wait until 3 AM UTC (8:30 AM IST - quiet time for most users)
    now = datetime.datetime.utcnow()
    target_hour = 3  # 3 AM UTC
    
    # Calculate next 3 AM
    if now.hour >= target_hour:
        # If it's already past 3 AM today, wait until tomorrow's 3 AM
        next_run = (now + datetime.timedelta(days=1)).replace(hour=target_hour, minute=0, second=0, microsecond=0)
    else:
        # If it's before 3 AM, run today at 3 AM
        next_run = now.replace(hour=target_hour, minute=0, second=0, microsecond=0)
    
    wait_seconds = (next_run - now).total_seconds()
    print(f"‚è∞ Next auto-update scheduled for: {next_run.strftime('%Y-%m-%d %H:%M UTC')} (in {wait_seconds/3600:.1f} hours)")
    await asyncio.sleep(wait_seconds)
    
    print("\nüîÑ Starting weekly auto-update...")
    
    # Scrape wikis
    sbor_pages = await scrape_wiki_pages(SBOR_WIKI_URL, "SBOR", SBOR_WIKI_DATA.get('pages', {}))
    SBOR_WIKI_DATA['pages'] = sbor_pages
    SBOR_WIKI_DATA['last_update'] = datetime.datetime.utcnow().isoformat()
    save_json(SBOR_WIKI_FILE, SBOR_WIKI_DATA)
    
    blox_pages = await scrape_wiki_pages(BLOXFRUITS_WIKI_URL, "Blox Fruits", BLOXFRUITS_WIKI_DATA.get('pages', {}))
    BLOXFRUITS_WIKI_DATA['pages'] = blox_pages
    BLOXFRUITS_WIKI_DATA['last_update'] = datetime.datetime.utcnow().isoformat()
    save_json(BLOXFRUITS_WIKI_FILE, BLOXFRUITS_WIKI_DATA)
    
    # Scrape YouTube
    youtube_vids = await scrape_youtube_channel()
    YOUTUBE_DATA['videos'] = youtube_vids
    YOUTUBE_DATA['last_update'] = datetime.datetime.utcnow().isoformat()
    save_json(YOUTUBE_DATA_FILE, YOUTUBE_DATA)
    
    print(f"‚úÖ Weekly auto-update complete! Next update: {(datetime.datetime.utcnow() + datetime.timedelta(days=7)).strftime('%Y-%m-%d %H:%M UTC')}\n")

@auto_update_data.before_loop
async def before_auto_update():
    """Wait until bot is ready before starting the update loop"""
    await bot.wait_until_ready()

# --- HELPER FUNCTIONS ---
def staff_or_admin(user):
    if not hasattr(user, 'roles'):
        return False
    return any(r.id == CSR_STAFF_ROLE_ID for r in user.roles) or user.guild_permissions.administrator

def admin_only(interaction):
    try:
        return interaction.user.guild_permissions.administrator
    except Exception:
        return False

async def get_member_count(group_id):
    try:
        url = f"https://groups.roblox.com/v1/groups/{group_id}"
        async with aiohttp.ClientSession() as session:
            async with session.get(url, timeout=10) as response:
                if response.status == 200:
                    data = await response.json()
                    return data.get("memberCount", "Error")
    except Exception as e:
        print(f"Failed to get member count: {e}")
    return "Error"

async def get_roblox_user_info(user_id):
    """Fetch Roblox username and display name from User ID"""
    try:
        url = f"https://users.roblox.com/v1/users/{user_id}"
        async with aiohttp.ClientSession() as session:
            async with session.get(url, timeout=10) as response:
                if response.status == 200:
                    data = await response.json()
                    username = data.get("name", "Unknown")
                    display_name = data.get("displayName", username)
                    return username, display_name
    except Exception as e:
        print(f"Failed to fetch Roblox user: {e}")
    return None, None

async def update_nickname(member, roblox_username, display_name=None):
    try:
        # Format: display_name (@username) or just username if no display name
        nickname = f"{display_name} (@{roblox_username})" if display_name else roblox_username
        await member.edit(nick=nickname)
        return True
    except Exception as e:
        print(f"Failed to update nickname: {e}")
        return False

# --- SMART SEARCH SYSTEM ---
def search_faqs(query):
    """Search guild FAQs"""
    query_lower = query.lower()
    for faq in GUILD_FAQS['faqs']:
        if any(keyword in query_lower for keyword in faq['keywords']):
            return faq['answer'], None
    return None, None

def search_wiki(query, wiki_data):
    """Search wiki pages"""
    query_lower = query.lower()
    best_match = None
    best_score = 0
    
    for page_key, page_data in wiki_data['pages'].items():
        # Check if query matches title or content
        title_match = query_lower in page_key
        content_match = query_lower in page_data['content'].lower()
        
        if title_match or content_match:
            score = (2 if title_match else 0) + (1 if content_match else 0)
            if score > best_score:
                best_score = score
                best_match = page_data
    
    if best_match:
        return best_match['content'][:500], best_match['url']
    return None, None

def search_youtube(query):
    """Search YouTube transcripts"""
    query_lower = query.lower()
    matches = []
    
    for video_id, video_data in YOUTUBE_DATA['videos'].items():
        if video_data['transcript']:
            if query_lower in video_data['title'].lower() or query_lower in video_data['transcript'].lower():
                matches.append((video_data['title'], video_data['url']))
    
    return matches[:3]  # Return top 3 matches

# --- SMART AI CHAT ---
async def chat_with_ai(message, channel_id):
    """Smart AI with multi-source search"""
    msg_lower = message.lower()
    sources = []
    
    # Casual responses
    if any(word in msg_lower for word in ["hi", "hello", "hey", "sup", "yo"]):
        return random.choice(CASUAL_RESPONSES['greetings']), []
    
    if "thanks" in msg_lower or "thank you" in msg_lower:
        return random.choice(CASUAL_RESPONSES['thanks']), []
    
    if any(word in msg_lower for word in ["bye", "goodbye", "cya"]):
        return random.choice(CASUAL_RESPONSES['goodbye']), []
    
    # Creator question
    if "who made" in msg_lower or "who created" in msg_lower:
        return f"I was created by **{BOT_AUTHOR}** (kiku)! üõ†Ô∏è", []
    
    # Search FAQs first
    faq_answer, _ = search_faqs(message)
    if faq_answer:
        return faq_answer, []
    
    # Search SBOR wiki
    if "sbor" in msg_lower or "sword" in msg_lower:
        answer, url = search_wiki(message, SBOR_WIKI_DATA)
        if answer:
            sources.append(("SBOR Wiki", url))
            return answer, sources
    
    # Search Blox Fruits wiki
    if "blox" in msg_lower or "fruit" in msg_lower:
        answer, url = search_wiki(message, BLOXFRUITS_WIKI_DATA)
        if answer:
            sources.append(("Blox Fruits Wiki", url))
            return answer, sources
    
    # Search YouTube
    video_matches = search_youtube(message)
    if video_matches:
        response = "Check out these videos from our channel:\n"
        for title, url in video_matches:
            response += f"‚Ä¢ [{title}]({url})\n"
        return response, []
    
    # Default
    return "Hmm, I'm not sure! Try asking staff or check our wikis/videos! ü§î", []

async def check_message_with_ai(message_content):
    """Basic moderation"""
    if not AI_MODERATION_ENABLED:
        return False, None
    
    toxic_patterns = [r'kys', r'kill yourself', r'hate you']
    for pattern in toxic_patterns:
        if re.search(pattern, message_content.lower()):
            return True, "Toxic content detected"
    return False, None

# --- VERIFICATION SYSTEM (Same as before) ---
class CaptchaModal(ui.Modal, title="Human Verification"):
    def __init__(self, answer):
        super().__init__()
        self.correct_answer = answer
        
    captcha_answer = ui.TextInput(
        label="Answer the math problem",
        placeholder="Enter the answer (numbers only)",
        required=True,
        max_length=10
    )
    
    roblox_id = ui.TextInput(
        label="Your Roblox User ID",
        placeholder="Example: 123456789",
        required=True,
        max_length=20
    )
    
    async def on_submit(self, interaction: discord.Interaction):
        user_answer = self.captcha_answer.value.strip()
        user_id = self.roblox_id.value.strip()
        
        if user_answer != str(self.correct_answer):
            await interaction.response.send_message("‚ùå Wrong captcha!", ephemeral=True)
            return
        
        if not user_id.isdigit():
            await interaction.response.send_message("‚ùå Invalid User ID!", ephemeral=True)
            return
        
        await interaction.response.defer(ephemeral=True)
        
        username, display_name = await get_roblox_user_info(user_id)
        
        if not username:
            await interaction.followup.send("‚ùå User ID not found!", ephemeral=True)
            return
        
        await update_nickname(interaction.user, username, display_name)
        
        display_text = f"{display_name} (@{username})"
        view = MemberVisitorView(username, display_name, user_id, interaction.user)
        
        await interaction.followup.send(
            f"‚úÖ **Verified!**\n**Roblox:** {display_text}\n**ID:** {user_id}\n\nAre you a **CSR Member** or **Visitor**?",
            view=view,
            ephemeral=True
        )

class VerificationStartView(ui.View):
    def __init__(self):
        super().__init__(timeout=None)
    
    @ui.button(label="üîê Get Verified", style=discord.ButtonStyle.green, custom_id="start_verify_captcha")
    async def start_verification(self, interaction: discord.Interaction, button: ui.Button):
        num1, num2 = random.randint(1, 20), random.randint(1, 20)
        operation = random.choice(["+", "-", "*"])
        answer = eval(f"{num1}{operation}{num2}")
        
        modal = CaptchaModal(answer)
        modal.captcha_answer.label = f"What is {num1} {operation} {num2}?"
        await interaction.response.send_modal(modal)

class MemberVisitorView(ui.View):
    def __init__(self, roblox_username, display_name, roblox_id, user):
        super().__init__(timeout=120)
        self.roblox_username = roblox_username
        self.display_name = display_name
        self.roblox_id = roblox_id
        self.user = user
    
    @ui.button(label="üè∞ CSR Member", style=discord.ButtonStyle.primary)
    async def member_button(self, interaction: discord.Interaction, button: ui.Button):
        await interaction.response.send_message(
            "Upload a screenshot of your SBOR guild page (3 minutes).",
            ephemeral=True
        )
        
        def check(m):
            return m.author.id == interaction.user.id and m.attachments and isinstance(m.channel, discord.DMChannel)
        
        try:
            screenshot_msg = await bot.wait_for('message', timeout=180, check=check)
            
            modlog = bot.get_channel(MODLOG_CHANNEL_ID)
            embed = discord.Embed(
                title="üî∞ Member Verification",
                description=f"**User:** {self.user.mention}\n**Roblox:** {self.roblox_username} (@{self.display_name})\n**ID:** {self.roblox_id}",
                color=discord.Color.blue()
            )
            embed.set_image(url=screenshot_msg.attachments[0].url)
            
            approval_view = StaffApprovalView(self.user, "member", self.roblox_username, self.roblox_id)
            await modlog.send(f"<@&{CSR_STAFF_ROLE_ID}>", embed=embed, view=approval_view)
            await interaction.user.send("‚úÖ Sent to staff!")
        except asyncio.TimeoutError:
            await interaction.user.send("‚è∞ Timeout!")
    
    @ui.button(label="üë§ Visitor", style=discord.ButtonStyle.secondary)
    async def visitor_button(self, interaction: discord.Interaction, button: ui.Button):
        await interaction.response.send_message("What guild are you from? (1 minute)", ephemeral=True)
        
        def check(m):
            return m.author.id == interaction.user.id and isinstance(m.channel, discord.DMChannel)
        
        try:
            guild_msg = await bot.wait_for('message', timeout=60, check=check)
            visitor_guild = guild_msg.content.strip()
            
            modlog = bot.get_channel(MODLOG_CHANNEL_ID)
            embed = discord.Embed(
                title="üë§ Visitor Verification",
                description=f"**User:** {self.user.mention}\n**Roblox:** {self.roblox_username}\n**Guild:** {visitor_guild}",
                color=discord.Color.green()
            )
            
            approval_view = StaffApprovalView(self.user, "visitor", self.roblox_username, self.roblox_id)
            await modlog.send(f"<@&{CSR_STAFF_ROLE_ID}>", embed=embed, view=approval_view)
            await interaction.user.send("‚úÖ Sent to staff!")
        except asyncio.TimeoutError:
            await interaction.user.send("‚è∞ Timeout!")

class StaffApprovalView(ui.View):
    def __init__(self, user, user_type, roblox_username, roblox_id):
        super().__init__(timeout=None)
        self.user = user
        self.user_type = user_type
        self.roblox_username = roblox_username
        self.roblox_id = roblox_id
    
    @ui.button(label="‚úÖ Approve", style=discord.ButtonStyle.success, custom_id="approve_verify")
    async def approve_button(self, interaction: discord.Interaction, button: ui.Button):
        if not staff_or_admin(interaction.user):
            await interaction.response.send_message("‚ùå Staff only!", ephemeral=True)
            return
        
        guild = interaction.guild
        member = guild.get_member(self.user.id)
        
        if not member:
            await interaction.response.send_message("‚ùå User not found!", ephemeral=True)
            return
        
        role_id = MEMBER_APPROVED_ROLE_ID if self.user_type == "member" else VISITOR_ROLE_ID
        role = guild.get_role(role_id)
        await member.add_roles(role)
        
        pending = guild.get_role(VERIFICATION_PENDING_ROLE_ID)
        if pending and pending in member.roles:
            await member.remove_roles(pending)
        
        await self.user.send(f"üéâ Verified as {self.user_type}! Welcome to CSR!")
        await interaction.response.send_message(f"‚úÖ Approved!", ephemeral=True)
        
        for item in self.children:
            item.disabled = True
        await interaction.message.edit(view=self)
    
    @ui.button(label="‚ùå Deny", style=discord.ButtonStyle.danger, custom_id="deny_verify")
    async def deny_button(self, interaction: discord.Interaction, button: ui.Button):
        if not staff_or_admin(interaction.user):
            await interaction.response.send_message("‚ùå Staff only!", ephemeral=True)
            return
        
        await self.user.send("‚ùå Verification denied. Contact staff!")
        await interaction.response.send_message("‚ùå Denied", ephemeral=True)
        
        for item in self.children:
            item.disabled = True
        await interaction.message.edit(view=self)

# --- STARTUP ---
@bot.event
async def on_ready():
    print(f"üöÄ CSR Bot v{BOT_VERSION} ONLINE!")
    print(f"üë§ {bot.user}")
    print(f"üìö SBOR Wiki: {len(SBOR_WIKI_DATA['pages'])} pages")
    print(f"üçé Blox Fruits Wiki: {len(BLOXFRUITS_WIKI_DATA['pages'])} pages")
    print(f"üé• YouTube: {len(YOUTUBE_DATA['videos'])} videos")
    print(f"üí° FAQs: {len(GUILD_FAQS['faqs'])}")
    
    bot.add_view(VerificationStartView())
    bot.add_view(StaffApprovalView(None, None, None, None))
    
    try:
        synced = await bot.tree.sync()
        print(f"‚ö° Synced {len(synced)} commands")
    except Exception as e:
        print(f"‚ùå Sync error: {e}")
    
    # Start tasks
    if not auto_update_data.is_running():
        auto_update_data.start()
    
    bot.loop.create_task(setup_verification_channel())
    bot.loop.create_task(update_permanent_message())
    bot.loop.create_task(daily_check())
    
    # Only run initial update if data files are empty (first time setup)
    if not SBOR_WIKI_DATA['pages'] and not BLOXFRUITS_WIKI_DATA['pages']:
        print("\n‚ö†Ô∏è No wiki data found! This is your first run.")
        print("üìå Use /forceupdate command to manually scrape wikis when ready.")
        print("üìå Or wait until next scheduled weekly update.")
    else:
        print(f"‚úÖ Loaded existing data - no initial scrape needed!")
        print(f"üìö SBOR: {len(SBOR_WIKI_DATA['pages'])} pages (Last: {SBOR_WIKI_DATA.get('last_update', 'Unknown')[:10]})")
        print(f"üçé Blox Fruits: {len(BLOXFRUITS_WIKI_DATA['pages'])} pages (Last: {BLOXFRUITS_WIKI_DATA.get('last_update', 'Unknown')[:10]})")
        print(f"üé• YouTube: {len(YOUTUBE_DATA['videos'])} videos (Last: {YOUTUBE_DATA.get('last_update', 'Unknown')[:10]})")

async def setup_verification_channel():
    await bot.wait_until_ready()
    channel = bot.get_channel(VERIFICATION_CHANNEL_ID)
    if not channel:
        return
    
    async for msg in channel.history(limit=10):
        if msg.author == bot.user and msg.embeds and "Verification" in msg.embeds[0].title:
            return
    
    embed = discord.Embed(
        title="üîê CSR Verification",
        description="Welcome! Click below to verify.\n\n**You'll need:**\n‚Ä¢ Captcha\n‚Ä¢ Roblox User ID\n‚Ä¢ Screenshot (members only)",
        color=discord.Color.blue()
    )
    embed.set_thumbnail(url=GUILD_IMAGE)
    await channel.send(embed=embed, view=VerificationStartView())

# --- MESSAGE HANDLER ---
@bot.event
async def on_message(message):
    if message.author.bot:
        return
    
    # AI Chat
    bot_mentioned = bot.user in message.mentions or message.content.lower().startswith("csr ")
    
    if bot_mentioned:
        async with message.channel.typing():
            clean_msg = message.content
            for mention in message.mentions:
                clean_msg = clean_msg.replace(f"<@{mention.id}>", "")
            clean_msg = re.sub(r"^csr\s+", "", clean_msg, flags=re.IGNORECASE).strip()
            
            if clean_msg:
                response, sources = await chat_with_ai(clean_msg, message.channel.id)
                
                # Add sources if any
                if sources:
                    response += "\n\n**üìö Sources:**\n"
                    for source_name, source_url in sources:
                        response += f"‚Ä¢ [{source_name}]({source_url})\n"
                
                # Add disclaimer
                response += "\n\n_‚ö†Ô∏è AI responses are ~99% accurate. Always verify important info!_"
                
                await message.reply(response, mention_author=False)
        return
    
    # Moderation
    if CHAT_FILTER_ENABLED:
        flagged_by_regex = BAD_WORDS_REGEX and BAD_WORDS_REGEX.search(message.content.lower())
        flagged_by_ai, ai_reason = await check_message_with_ai(message.content) if AI_MODERATION_ENABLED else (False, None)
        
        if flagged_by_regex or flagged_by_ai:
            try:
                await message.delete()
                modlog = bot.get_channel(MODLOG_CHANNEL_ID)
                detection = "Bad word filter" if flagged_by_regex else f"AI: {ai_reason}"
                await modlog.send(
                    f"‚ö†Ô∏è {message.author.mention} in <#{message.channel.id}>\n"
                    f"Detection: {detection}\nContent: `{message.content[:100]}`"
                )
                await message.channel.send(
                    f"{message.author.mention}, message removed. Keep it respectful! üõ°Ô∏è",
                    delete_after=7
                )
            except Exception as e:
                print(f"Moderation error: {e}")
    
    await bot.process_commands(message)

# --- MEMBER COUNT TRACKER ---
async def update_permanent_message():
    await bot.wait_until_ready()
    channel = bot.get_channel(CHANNEL_ID)
    if not channel:
        return

    message = None
    async for msg in channel.history(limit=20):
        if msg.author == bot.user and msg.embeds and "Member Count" in msg.embeds[0].title:
            message = msg
            break
    
    if not message:
        message = await channel.send("Starting...")

    last_count = None
    while True:
        try:
            count = await get_member_count(GROUP_ID)
            if count != last_count:
                embed = discord.Embed(
                    title="üåü Roblox Community Live Member Count",
                    description="Tracking CSR Roblox Group\n\nüü¢ _Updates every 5 minutes_",
                    color=discord.Color.gold()
                )
                embed.set_thumbnail(url=GUILD_IMAGE)
                embed.add_field(name="üë• Total Members", value=f"**`{count}`**", inline=False)
                embed.set_footer(text=f"Last updated: {datetime.datetime.utcnow():%Y-%m-%d %H:%M UTC}")
                await message.edit(content="", embed=embed)
                last_count = count
        except Exception as e:
            print(f"Member count error: {e}")
        
        await asyncio.sleep(UPDATE_INTERVAL)

# --- WELCOME MESSAGE ---
@bot.event
async def on_member_join(member):
    embed = discord.Embed(
        title="üéÆ Welcome to CSR!",
        description=f"Hey {member.mention}! Let's get you started! üî•",
        color=discord.Color.blue()
    )
    embed.set_thumbnail(url=GUILD_IMAGE)
    embed.add_field(
        name="üìã Step 1: Verify",
        value=f"Go to <#{VERIFICATION_CHANNEL_ID}> and click **Get Verified**!",
        inline=False
    )
    embed.add_field(
        name="‚ùì Need Help?",
        value=f"Ask in <#{HELP_CHANNEL_ID}>! Staff is here to help! üõ°Ô∏è",
        inline=False
    )
    embed.add_field(
        name="üéØ What We Offer",
        value="üè¶ Guild Bank\n‚öîÔ∏è Grinding parties\nüéÆ Multi-game support\nüéâ Events & giveaways",
        inline=False
    )
    embed.set_footer(text=f"CSR Bot v{BOT_VERSION}")
    
    try:
        await member.send(embed=embed)
    except:
        pass

# --- DAILY CHECK ---
async def daily_check():
    await bot.wait_until_ready()
    channel = bot.get_channel(DAILYCHECKS)
    if not channel:
        return

    while True:
        now = datetime.datetime.utcnow()
        target = now.replace(hour=14, minute=0, second=0, microsecond=0)
        if now > target:
            target += datetime.timedelta(days=1)
        
        await asyncio.sleep((target - now).total_seconds())

        try:
            embed = discord.Embed(
                title="üìã CSR Daily Check",
                description=f"React with {CSR_EMOJI} to show you're active!\n\n**Time:** 7:30 PM IST | 2:00 PM UTC",
                color=discord.Color.blue()
            )
            embed.set_thumbnail(url=GUILD_IMAGE)
            msg = await channel.send("@everyone", embed=embed)
            await msg.add_reaction(CSR_EMOJI)
        except Exception as e:
            print(f"Daily check error: {e}")
        
        await asyncio.sleep(86400)

# --- SLASH COMMANDS ---
@bot.tree.command(name="forceupdate", description="Manually update wiki/YouTube data (Admin only)")
async def forceupdate(interaction: discord.Interaction):
    if not admin_only(interaction):
        await interaction.response.send_message("‚ùå Admin only!", ephemeral=True)
        return
    
    await interaction.response.defer(ephemeral=True)
    await interaction.followup.send("üîÑ Starting manual update...")
    
    await auto_update_data()
    
    await interaction.followup.send(
        f"‚úÖ **Update Complete!**\n"
        f"üìö SBOR: {len(SBOR_WIKI_DATA['pages'])} pages\n"
        f"üçé Blox Fruits: {len(BLOXFRUITS_WIKI_DATA['pages'])} pages\n"
        f"üé• YouTube: {len(YOUTUBE_DATA['videos'])} videos",
        ephemeral=True
    )

@bot.tree.command(name="addfaq", description="Add a new FAQ (Staff only)")
async def addfaq(interaction: discord.Interaction, question: str, answer: str, keywords: str):
    if not staff_or_admin(interaction.user):
        await interaction.response.send_message("‚ùå Staff only!", ephemeral=True)
        return
    
    keyword_list = [k.strip().lower() for k in keywords.split(',')]
    
    new_faq = {
        "id": GUILD_FAQS['next_id'],
        "question": question,
        "answer": answer,
        "keywords": keyword_list
    }
    
    GUILD_FAQS['faqs'].append(new_faq)
    GUILD_FAQS['next_id'] += 1
    save_json(GUILD_FAQS_FILE, GUILD_FAQS)
    
    await interaction.response.send_message(
        f"‚úÖ **FAQ Added!** (ID: {new_faq['id']})\n**Q:** {question}\n**A:** {answer}",
        ephemeral=True
    )

@bot.tree.command(name="listfaqs", description="List all FAQs (Staff only)")
async def listfaqs(interaction: discord.Interaction):
    if not staff_or_admin(interaction.user):
        await interaction.response.send_message("‚ùå Staff only!", ephemeral=True)
        return
    
    if not GUILD_FAQS['faqs']:
        await interaction.response.send_message("No FAQs yet!", ephemeral=True)
        return
    
    embed = discord.Embed(title="üí° Guild FAQs", color=discord.Color.blue())
    
    for faq in GUILD_FAQS['faqs']:
        embed.add_field(
            name=f"#{faq['id']}: {faq['question']}",
            value=f"{faq['answer'][:100]}...\nKeywords: {', '.join(faq['keywords'])}",
            inline=False
        )
    
    await interaction.response.send_message(embed=embed, ephemeral=True)

@bot.tree.command(name="removefaq", description="Remove an FAQ by ID (Staff only)")
async def removefaq(interaction: discord.Interaction, faq_id: int):
    if not staff_or_admin(interaction.user):
        await interaction.response.send_message("‚ùå Staff only!", ephemeral=True)
        return
    
    for i, faq in enumerate(GUILD_FAQS['faqs']):
        if faq['id'] == faq_id:
            removed = GUILD_FAQS['faqs'].pop(i)
            save_json(GUILD_FAQS_FILE, GUILD_FAQS)
            await interaction.response.send_message(f"‚úÖ Removed FAQ #{faq_id}: {removed['question']}", ephemeral=True)
            return
    
    await interaction.response.send_message(f"‚ùå FAQ #{faq_id} not found!", ephemeral=True)

@bot.tree.command(name="wikiinfo", description="Show wiki/YouTube data stats")
async def wikiinfo(interaction: discord.Interaction):
    embed = discord.Embed(title="üìä Knowledge Base Stats", color=discord.Color.green())
    
    sbor_update = SBOR_WIKI_DATA.get('last_update', 'Never')
    blox_update = BLOXFRUITS_WIKI_DATA.get('last_update', 'Never')
    yt_update = YOUTUBE_DATA.get('last_update', 'Never')
    
    embed.add_field(name="üìö SBOR Wiki", value=f"{len(SBOR_WIKI_DATA['pages'])} pages\nLast: {sbor_update[:10] if sbor_update != 'Never' else 'Never'}", inline=True)
    embed.add_field(name="üçé Blox Fruits Wiki", value=f"{len(BLOXFRUITS_WIKI_DATA['pages'])} pages\nLast: {blox_update[:10] if blox_update != 'Never' else 'Never'}", inline=True)
    embed.add_field(name="üé• YouTube Videos", value=f"{len(YOUTUBE_DATA['videos'])} videos\nLast: {yt_update[:10] if yt_update != 'Never' else 'Never'}", inline=True)
    embed.add_field(name="üí° Guild FAQs", value=f"{len(GUILD_FAQS['faqs'])} FAQs", inline=True)
    
    embed.set_footer(text="Auto-updates weekly at 3 AM UTC (8:30 AM IST) ‚Ä¢ Use /forceupdate for manual update")
    await interaction.response.send_message(embed=embed)

@bot.tree.command(name="setupverify", description="Setup verification message (Admin only)")
async def setupverify(interaction: discord.Interaction):
    if not admin_only(interaction):
        await interaction.response.send_message("‚ùå Admin only!", ephemeral=True)
        return
    await setup_verification_channel()
    await interaction.response.send_message("‚úÖ Posted!", ephemeral=True)

@bot.tree.command(name="chatfilter", description="Toggle chat filter (Staff only)")
async def chatfilter(interaction: discord.Interaction, state: str):
    if not staff_or_admin(interaction.user):
        await interaction.response.send_message("‚ùå Staff only!", ephemeral=True)
        return
    
    global CHAT_FILTER_ENABLED
    if state.lower() == "on":
        CHAT_FILTER_ENABLED = True
        await interaction.response.send_message("‚úÖ Filter enabled", ephemeral=True)
    elif state.lower() == "off":
        CHAT_FILTER_ENABLED = False
        await interaction.response.send_message("‚ö†Ô∏è Filter disabled", ephemeral=True)

@bot.tree.command(name="aimod", description="Toggle AI moderation (Staff only)")
async def aimod(interaction: discord.Interaction, state: str):
    if not staff_or_admin(interaction.user):
        await interaction.response.send_message("‚ùå Staff only!", ephemeral=True)
        return
    
    global AI_MODERATION_ENABLED
    if state.lower() == "on":
        AI_MODERATION_ENABLED = True
        await interaction.response.send_message("‚úÖ AI mod enabled", ephemeral=True)
    elif state.lower() == "off":
        AI_MODERATION_ENABLED = False
        await interaction.response.send_message("‚ö†Ô∏è AI mod disabled", ephemeral=True)

@bot.tree.command(name="aboutthisbot", description="Bot information")
async def aboutthisbot(interaction: discord.Interaction):
    embed = discord.Embed(
        title="ü§ñ CSR Bot v3.0.0",
        description="Your ELITE guild companion! üî•",
        color=discord.Color.blue()
    )
    embed.add_field(name="üë®‚Äçüíª Creator", value=BOT_AUTHOR, inline=True)
    embed.add_field(name="üìÖ Created", value=BOT_CREATED, inline=True)
    embed.add_field(name="üî¢ Version", value=BOT_VERSION, inline=True)
    embed.add_field(name="‚ú® Latest", value=BOT_UPDATE, inline=False)
    embed.add_field(
        name="üß† Features",
        value=(
            "‚Ä¢ Wiki scraper (SBOR/Blox Fruits)\n"
            "‚Ä¢ YouTube transcript search\n"
            "‚Ä¢ Smart AI with sources\n"
            "‚Ä¢ Auto Roblox username lookup\n"
            "‚Ä¢ Staff FAQ management\n"
            "‚Ä¢ Content moderation\n"
            "‚Ä¢ Auto-updates every 24hrs"
        ),
        inline=False
    )
    await interaction.response.send_message(embed=embed)

@bot.tree.command(name="help", description="Show all commands")
async def help_command(interaction: discord.Interaction):
    embed = discord.Embed(title="üõ†Ô∏è CSR Bot Commands", color=discord.Color.green())
    
    embed.add_field(
        name="üí¨ Chat",
        value="Mention me or say 'CSR' + your question!\nI search wikis, YouTube, and FAQs!",
        inline=False
    )
    embed.add_field(name="/aboutthisbot", value="Bot info", inline=False)
    embed.add_field(name="/wikiinfo", value="Knowledge base stats", inline=False)
    embed.add_field(name="/suggestions <msg>", value="Send suggestion to staff", inline=False)
    
    if staff_or_admin(interaction.user):
        embed.add_field(name="\n**üõ°Ô∏è Staff Commands**", value="_ _", inline=False)
        embed.add_field(name="/forceupdate", value="Manual wiki/YouTube update", inline=False)
        embed.add_field(name="/addfaq <q> <a> <keywords>", value="Add FAQ", inline=False)
        embed.add_field(name="/listfaqs", value="Show all FAQs", inline=False)
        embed.add_field(name="/removefaq <id>", value="Remove FAQ", inline=False)
        embed.add_field(name="/setupverify", value="Post verification message", inline=False)
        embed.add_field(name="/kick, /ban, /unban, /mute, /unmute", value="Moderation", inline=False)
        embed.add_field(name="/addroles, /removeroles", value="Role management", inline=False)
        embed.add_field(name="/chatfilter, /aimod", value="Toggle filters", inline=False)
        embed.add_field(name="/announcement", value="Send announcement", inline=False)
    
    embed.set_footer(text=f"CSR Bot v{BOT_VERSION} ‚Ä¢ Made by {BOT_AUTHOR}")
    await interaction.response.send_message(embed=embed)

@bot.tree.command(name="kick", description="Kick member (Staff only)")
async def kick(interaction: discord.Interaction, member: discord.Member, reason: str):
    if not staff_or_admin(interaction.user):
        await interaction.response.send_message("‚ùå No permission", ephemeral=True)
        return
    try:
        await member.kick(reason=reason)
        await interaction.response.send_message(f"‚úÖ Kicked {member.mention}", ephemeral=True)
    except Exception as e:
        await interaction.response.send_message(f"‚ùå Error: {e}", ephemeral=True)

@bot.tree.command(name="ban", description="Ban member (Staff only)")
async def ban(interaction: discord.Interaction, member: discord.Member, reason: str):
    if not staff_or_admin(interaction.user):
        await interaction.response.send_message("‚ùå No permission", ephemeral=True)
        return
    try:
        await member.ban(reason=reason)
        await interaction.response.send_message(f"‚úÖ Banned {member.mention}", ephemeral=True)
    except Exception as e:
        await interaction.response.send_message(f"‚ùå Error: {e}", ephemeral=True)

@bot.tree.command(name="unban", description="Unban user (Staff only)")
async def unban(interaction: discord.Interaction, user: discord.User):
    if not staff_or_admin(interaction.user):
        await interaction.response.send_message("‚ùå No permission", ephemeral=True)
        return
    try:
        await interaction.guild.unban(user)
        await interaction.response.send_message(f"‚úÖ Unbanned {user.mention}", ephemeral=True)
    except Exception as e:
        await interaction.response.send_message(f"‚ùå Error: {e}", ephemeral=True)

@bot.tree.command(name="mute", description="Mute member (Staff only)")
async def mute(interaction: discord.Interaction, member: discord.Member, reason: str):
    if not staff_or_admin(interaction.user):
        await interaction.response.send_message("‚ùå No permission", ephemeral=True)
        return
    
    mute_role = interaction.guild.get_role(MUTED_ROLE_ID)
    if not mute_role:
        await interaction.response.send_message("‚ùå Muted role not found!", ephemeral=True)
        return
    
    try:
        await member.add_roles(mute_role, reason=reason)
        await interaction.response.send_message(f"‚úÖ Muted {member.mention}", ephemeral=True)
    except Exception as e:
        await interaction.response.send_message(f"‚ùå Error: {e}", ephemeral=True)

@bot.tree.command(name="unmute", description="Unmute member (Staff only)")
async def unmute(interaction: discord.Interaction, member: discord.Member):
    if not staff_or_admin(interaction.user):
        await interaction.response.send_message("‚ùå No permission", ephemeral=True)
        return
    
    mute_role = interaction.guild.get_role(MUTED_ROLE_ID)
    if not mute_role:
        await interaction.response.send_message("‚ùå Muted role not found!", ephemeral=True)
        return
    
    try:
        await member.remove_roles(mute_role)
        await interaction.response.send_message(f"‚úÖ Unmuted {member.mention}", ephemeral=True)
    except Exception as e:
        await interaction.response.send_message(f"‚ùå Error: {e}", ephemeral=True)

@bot.tree.command(name="announcement", description="Send announcement (Staff only)")
async def announcement(interaction: discord.Interaction, channel: discord.TextChannel, message: str):
    if not staff_or_admin(interaction.user):
        await interaction.response.send_message("‚ùå No permission", ephemeral=True)
        return
    try:
        await channel.send(message)
        await interaction.response.send_message(f"‚úÖ Sent to {channel.mention}", ephemeral=True)
    except Exception as e:
        await interaction.response.send_message(f"‚ùå Error: {e}", ephemeral=True)

@bot.tree.command(name="suggestions", description="Send anonymous suggestion")
async def suggestions(interaction: discord.Interaction, message: str):
    channel = interaction.guild.get_channel(MODLOG_CHANNEL_ID)
    staff_role = interaction.guild.get_role(CSR_STAFF_ROLE_ID)
    
    embed = discord.Embed(
        title="üí° New Suggestion",
        description=message,
        color=discord.Color.blue(),
        timestamp=datetime.datetime.utcnow()
    )
    embed.set_footer(text=f"From: {interaction.user.name}")
    
    await channel.send(f"{staff_role.mention}", embed=embed)
    await interaction.response.send_message("‚úÖ Suggestion sent!", ephemeral=True)

@bot.tree.command(name="addroles", description="Add roles (Staff only)")
async def addroles(interaction: discord.Interaction, member: discord.Member, roles: str):
    if not staff_or_admin(interaction.user):
        await interaction.response.send_message("‚ùå Staff only!", ephemeral=True)
        return
    
    role_list = [r.strip() for r in roles.split(',')]
    added_roles = []
    
    for role_input in role_list:
        role = None
        if role_input.startswith('<@&'):
            role = interaction.guild.get_role(int(role_input[3:-1]))
        elif role_input.isdigit():
            role = interaction.guild.get_role(int(role_input))
        else:
            role = discord.utils.get(interaction.guild.roles, name=role_input)
        
        if role and role not in member.roles:
            try:
                await member.add_roles(role)
                added_roles.append(role.name)
            except:
                pass
    
    if added_roles:
        await interaction.response.send_message(f"‚úÖ Added: {', '.join(added_roles)}", ephemeral=True)
    else:
        await interaction.response.send_message("‚ùå No roles added", ephemeral=True)

@bot.tree.command(name="removeroles", description="Remove roles (Staff only)")
async def removeroles(interaction: discord.Interaction, member: discord.Member, roles: str):
    if not staff_or_admin(interaction.user):
        await interaction.response.send_message("‚ùå Staff only!", ephemeral=True)
        return
    
    role_list = [r.strip() for r in roles.split(',')]
    removed_roles = []
    
    for role_input in role_list:
        role = None
        if role_input.startswith('<@&'):
            role = interaction.guild.get_role(int(role_input[3:-1]))
        elif role_input.isdigit():
            role = interaction.guild.get_role(int(role_input))
        else:
            role = discord.utils.get(interaction.guild.roles, name=role_input)
        
        if role and role in member.roles:
            try:
                await member.remove_roles(role)
                removed_roles.append(role.name)
            except:
                pass
    
    if removed_roles:
        await interaction.response.send_message(f"‚úÖ Removed: {', '.join(removed_roles)}", ephemeral=True)
    else:
        await interaction.response.send_message("‚ùå No roles removed", ephemeral=True)

# --- RUN BOT ---
if __name__ == "__main__":
    bot.run(TOKEN)
