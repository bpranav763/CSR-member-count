from dotenv import load_dotenv
load_dotenv()

import discord
import aiohttp
import asyncio
import datetime
import re
import os
import json
from discord.ext import commands

# --- CONFIGURATION ---
TOKEN = os.getenv('DISCORD_BOT_TOKEN')
HF_TOKEN = os.getenv('HF_TOKEN')  # Hugging Face token (FREE and more reliable!)
if not TOKEN:
    raise ValueError("DISCORD_BOT_TOKEN environment variable is required!")
if not HF_TOKEN:
    raise ValueError("HF_TOKEN environment variable is required! Get it from huggingface.co/settings/tokens")

CHANNEL_ID = 1432803218919919666
GROUP_ID = '1003228779'
GUILD_IMAGE = 'https://tr.rbxcdn.com/180DAY-929c99c9ad05b139c8851f873606876e/150/150/Image/Webp/noFilter'
UPDATE_INTERVAL = 300
CSR_STAFF_ROLE_ID = 1430084386837102673
MODLOG_CHANNEL_ID = 1429402899649134664
DAILYCHECKS = 1433403158612279327
CSR_EMOJI = "<:CSR:1432804739447263333>"
MUTED_ROLE_ID = 1433893267816054844

BOT_VERSION = "2.1.0"
BOT_UPDATE = "Switched to Hugging Face AI (more reliable!), improved error handling"
BOT_AUTHOR = "kikusuka"
BOT_CREATED = "October 24, 2025"

# --- CONVERSATION MEMORY (simple in-memory, per channel) ---
conversation_memory = {}
MAX_MEMORY_PER_CHANNEL = 10

# --- BOT PERSONALITY & KNOWLEDGE ---
BOT_PERSONALITY = """You are the CSR Discord bot, a friendly and helpful assistant for the Champions of the Shattered Realm guild. 

Key facts about you:
- You were created by kikusuka (also called kiku)
- You're part of the CSR guild community for Roblox/SBOR
- You help with moderation, verification, and being a friendly companion
- The guild owner is <@1348989002631152354>
- You talk casually like a friend, not too formal
- You can be a bit playful and use gaming slang
- You help answer questions about the guild, bot commands, and general chat

Keep responses SHORT (1-3 sentences) unless asked for details. Be helpful but chill."""

# --- LOAD BAD WORDS ---
def load_bad_words(filepath="badwords.txt"):
    if not os.path.exists(filepath):
        print(f"Warning: {filepath} not found. Creating empty file.")
        with open(filepath, "w") as f:
            f.write("# Add bad words here, one per line\n")
        return set()
    
    with open(filepath, "r") as f:
        words = [line.strip().lower() for line in f if line.strip() and not line.startswith("#")]
    
    if not words:
        print("Warning: Bad words list is empty!")
    return set(words)

BAD_WORDS = load_bad_words()
BAD_WORDS_REGEX = re.compile(r"\b(" + "|".join(map(re.escape, BAD_WORDS)) + r")\b", re.IGNORECASE) if BAD_WORDS else None
CHAT_FILTER_ENABLED = True
AI_MODERATION_ENABLED = True

# --- DISCORD BOT ---
intents = discord.Intents.default()
intents.members = True
intents.message_content = True
bot = commands.Bot(command_prefix="/", intents=intents)

# --- HELPER FUNCTIONS ---
def staff_or_admin(user):
    if not hasattr(user, 'roles'):
        return False
    return any(r.id == CSR_STAFF_ROLE_ID for r in user.roles) or user.guild_permissions.administrator

def admin_only(interaction):
    try:
        return interaction.user.guild_permissions.administrator
    except Exception:
        return False

async def get_member_count(group_id):
    try:
        url = f"https://groups.roblox.com/v1/groups/{group_id}"
        async with aiohttp.ClientSession() as session:
            async with session.get(url, timeout=10) as response:
                if response.status == 200:
                    data = await response.json()
                    return data.get("memberCount", "Error")
    except Exception as e:
        print(f"Failed to get member count: {e}")
    return "Error"

async def update_nickname(member, roblox_username):
    try:
        nickname = f"{member.name} ({roblox_username})"
        await member.edit(nick=nickname)
        return True
    except Exception as e:
        print(f"Failed to update nickname: {e}")
        return False

# --- AI FUNCTIONS (Using FREE Hugging Face API) ---
async def check_message_with_ai(message_content):
    """Use FREE Hugging Face AI to detect inappropriate content"""
    if not AI_MODERATION_ENABLED:
        return False, None
    
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                "https://api-inference.huggingface.co/models/facebook/roberta-hate-speech-dynabench-r4-target",
                headers={
                    "Authorization": f"Bearer {HF_TOKEN}",
                    "Content-Type": "application/json"
                },
                json={"inputs": message_content},
                timeout=aiohttp.ClientTimeout(total=10)
            ) as response:
                if response.status == 200:
                    data = await response.json()
                    # Model returns hate/nothate classification
                    if isinstance(data, list) and len(data) > 0:
                        result = data[0]
                        if isinstance(result, list):
                            # Find hate label score
                            for item in result:
                                if item.get('label') == 'hate' and item.get('score', 0) > 0.5:
                                    return True, "Hate speech detected"
                    return False, None
                else:
                    print(f"AI moderation error: {response.status}")
                    return False, None
    except Exception as e:
        print(f"AI moderation error: {e}")
        return False, None

async def chat_with_ai(message, channel_id):
    """Have a conversation with FREE Hugging Face AI"""
    try:
        # Get conversation history
        if channel_id not in conversation_memory:
            conversation_memory[channel_id] = []
        
        history = conversation_memory[channel_id]
        
        # Build prompt with personality and history
        prompt = f"{BOT_PERSONALITY}\n\n"
        for msg in history[-6:]:  # Last 3 exchanges
            if msg['role'] == 'user':
                prompt += f"User: {msg['content']}\n"
            else:
                prompt += f"Bot: {msg['content']}\n"
        prompt += f"User: {message}\nBot:"
        
        async with aiohttp.ClientSession() as session:
            async with session.post(
                "https://api-inference.huggingface.co/models/mistralai/Mistral-7B-Instruct-v0.2",
                headers={
                    "Authorization": f"Bearer {HF_TOKEN}",
                    "Content-Type": "application/json"
                },
                json={
                    "inputs": prompt,
                    "parameters": {
                        "max_new_tokens": 150,
                        "temperature": 0.7,
                        "return_full_text": False
                    }
                },
                timeout=aiohttp.ClientTimeout(total=15)
            ) as response:
                if response.status == 200:
                    data = await response.json()
                    if isinstance(data, list) and len(data) > 0:
                        assistant_msg = data[0].get('generated_text', '').strip()
                        
                        # Clean up response
                        if assistant_msg.startswith('Bot:'):
                            assistant_msg = assistant_msg[4:].strip()
                        
                        if not assistant_msg:
                            return "Hmm, I'm not sure how to respond to that!"
                        
                        # Update memory
                        conversation_memory[channel_id].append({"role": "user", "content": message})
                        conversation_memory[channel_id].append({"role": "assistant", "content": assistant_msg})
                        
                        # Trim memory
                        if len(conversation_memory[channel_id]) > MAX_MEMORY_PER_CHANNEL * 2:
                            conversation_memory[channel_id] = conversation_memory[channel_id][-MAX_MEMORY_PER_CHANNEL * 2:]
                        
                        return assistant_msg
                    return "I'm having trouble thinking right now. Try again?"
                elif response.status == 503:
                    return "My AI brain is loading... try again in 20 seconds!"
                else:
                    error = await response.text()
                    print(f"AI chat error {response.status}: {error}")
                    return "Having some technical issues. Try again?"
    except asyncio.TimeoutError:
        return "My brain is too slow right now. Try again?"
    except Exception as e:
        print(f"AI chat error: {e}")
        return "Something broke in my brain. Try again?"

# --- STARTUP ---
@bot.event
async def on_ready():
    print(f"Logged in as {bot.user}")
    print(f"AI Moderation: {'Enabled' if AI_MODERATION_ENABLED else 'Disabled'}")
    print(f"Bad words loaded: {len(BAD_WORDS)}")
    
    try:
        synced = await bot.tree.sync()
        print(f"Synced {len(synced)} slash commands")
    except Exception as e:
        print(f"Command sync error: {e}")
    
    bot.loop.create_task(update_permanent_message())
    bot.loop.create_task(daily_check())

# --- MESSAGE MONITORING ---
LAST_ACTIVE = {}

@bot.event
async def on_message(message):
    if message.author.bot:
        return
    
    # Update last active
    LAST_ACTIVE[message.author.id] = datetime.datetime.utcnow()
    
    # Check if bot is mentioned or message starts with "csr"
    bot_mentioned = bot.user in message.mentions or message.content.lower().startswith("csr ")
    
    if bot_mentioned:
        # AI conversation mode
        async with message.channel.typing():
            # Remove bot mention from message
            clean_msg = message.content
            for mention in message.mentions:
                clean_msg = clean_msg.replace(f"<@{mention.id}>", "")
            clean_msg = re.sub(r"^csr\s+", "", clean_msg, flags=re.IGNORECASE).strip()
            
            if clean_msg:
                response = await chat_with_ai(clean_msg, message.channel.id)
                await message.reply(response, mention_author=False)
        return
    
    # Content moderation
    if CHAT_FILTER_ENABLED:
        flagged_by_regex = BAD_WORDS_REGEX and BAD_WORDS_REGEX.search(message.content.lower())
        flagged_by_ai = False
        ai_reason = None
        
        # Check with AI if regex didn't catch it
        if not flagged_by_regex and AI_MODERATION_ENABLED:
            flagged_by_ai, ai_reason = await check_message_with_ai(message.content)
        
        if flagged_by_regex or flagged_by_ai:
            try:
                await message.delete()
                modlog = bot.get_channel(MODLOG_CHANNEL_ID)
                
                detection_method = "Bad word filter" if flagged_by_regex else f"AI detection: {ai_reason}"
                await modlog.send(
                    f"‚ö†Ô∏è {message.author.mention} sent inappropriate content in <#{message.channel.id}>.\n"
                    f"Detection: {detection_method}\n"
                    f"Content: `{message.content[:100]}`"
                )
                
                await message.channel.send(
                    f"{message.author.mention}, your message was removed. Please keep it respectful! üõ°Ô∏è",
                    delete_after=7
                )
            except Exception as e:
                print(f"Moderation error: {e}")
    
    await bot.process_commands(message)

# --- MEMBER COUNT TRACKER ---
async def update_permanent_message():
    await bot.wait_until_ready()
    channel = bot.get_channel(CHANNEL_ID)
    if not channel:
        print("ERROR: Member count channel not found.")
        return

    message = None
    async for msg in channel.history(limit=20):
        if msg.author == bot.user and msg.embeds and "Live Member Count" in msg.embeds[0].title:
            message = msg
            break
    
    if not message:
        message = await channel.send("Starting member counter...")

    last_count = None
    while True:
        try:
            count = await get_member_count(GROUP_ID)
            if count != last_count:
                embed = discord.Embed(
                    title="üåü Roblox Community Live Member Count",
                    description="Tracking **all members** in the CSR Roblox Group\n\nüü¢ _Updates every 5 minutes_",
                    color=discord.Color.gold()
                )
                embed.set_thumbnail(url=GUILD_IMAGE)
                embed.add_field(
                    name="üë• Total Members",
                    value=f"**`{count}`**",
                    inline=False
                )
                embed.set_footer(text=f"Last updated: {datetime.datetime.utcnow():%Y-%m-%d %H:%M UTC}")
                await message.edit(content="", embed=embed)
                last_count = count
        except Exception as e:
            print(f"Member count update error: {e}")
        
        await asyncio.sleep(UPDATE_INTERVAL)

# --- WELCOME MESSAGE ---
@bot.event
async def on_member_join(member):
    welcome = (
        f"**Welcome to Champions of the Shattered Realm (CSR), {member.mention}!** üéÆ\n\n"
        f"**Guild Owner:** <@1348989002631152354>\n\n"
        f"**What we offer:**\n"
        f"üè¶ Guild Bank & resource sharing\n"
        f"‚öîÔ∏è Friendly grinding parties\n"
        f"üéØ Multi-game support (Roblox, SBOR, and more)\n"
        f"‚úÖ Verification & community protection\n"
        f"üéâ Events & giveaways\n\n"
        f"**Ready to start?** Use `/help` or ask our staff!\n"
        f"Let's grow together in CSR! üí™"
    )
    try:
        await member.send(welcome)
    except Exception:
        pass

# --- DAILY CHECK ---
async def daily_check():
    await bot.wait_until_ready()
    channel = bot.get_channel(DAILYCHECKS)
    modlog = bot.get_channel(MODLOG_CHANNEL_ID)
    
    if not channel:
        print("ERROR: Daily check channel not found.")
        return

    while True:
        now = datetime.datetime.utcnow()
        target = now.replace(hour=14, minute=0, second=0, microsecond=0)
        if now > target:
            target += datetime.timedelta(days=1)
        
        wait_seconds = (target - now).total_seconds()
        await asyncio.sleep(wait_seconds)

        try:
            embed = discord.Embed(
                title="üìã CSR Daily Check",
                description=f"React with {CSR_EMOJI} to show you're active today!\n\n**Time:** 7:30 PM IST | 2:00 PM UTC | 10:00 AM EST",
                color=discord.Color.blue()
            )
            embed.set_thumbnail(url=GUILD_IMAGE)
            embed.set_footer(text="Daily participation helps keep the community active!")
            
            msg = await channel.send("@everyone", embed=embed)
            await msg.add_reaction(CSR_EMOJI)
        except Exception as e:
            print(f"Daily check error: {e}")
        
        await asyncio.sleep(86400)

# --- SLASH COMMANDS ---
@bot.tree.command(name="chatfilter", description="Toggle chat filter (staff only)")
async def chatfilter(interaction: discord.Interaction, state: str):
    if not staff_or_admin(interaction.user):
        await interaction.response.send_message("‚ùå Staff only!", ephemeral=True)
        return
    
    global CHAT_FILTER_ENABLED
    state = state.lower()
    if state == "on":
        CHAT_FILTER_ENABLED = True
        await interaction.response.send_message("‚úÖ Chat filter enabled", ephemeral=True)
    elif state == "off":
        CHAT_FILTER_ENABLED = False
        await interaction.response.send_message("‚ö†Ô∏è Chat filter disabled", ephemeral=True)
    else:
        await interaction.response.send_message("Usage: /chatfilter <on/off>", ephemeral=True)

@bot.tree.command(name="aimod", description="Toggle AI moderation (staff only)")
async def aimod(interaction: discord.Interaction, state: str):
    if not staff_or_admin(interaction.user):
        await interaction.response.send_message("‚ùå Staff only!", ephemeral=True)
        return
    
    global AI_MODERATION_ENABLED
    state = state.lower()
    if state == "on":
        AI_MODERATION_ENABLED = True
        await interaction.response.send_message("‚úÖ AI moderation enabled", ephemeral=True)
    elif state == "off":
        AI_MODERATION_ENABLED = False
        await interaction.response.send_message("‚ö†Ô∏è AI moderation disabled", ephemeral=True)
    else:
        await interaction.response.send_message("Usage: /aimod <on/off>", ephemeral=True)

@bot.tree.command(name="aboutthisbot", description="Bot information")
async def aboutthisbot(interaction: discord.Interaction):
    embed = discord.Embed(
        title="ü§ñ About CSR Bot",
        description="Your friendly CSR guild companion!",
        color=discord.Color.blue()
    )
    embed.add_field(name="üë®‚Äçüíª Created by", value=BOT_AUTHOR, inline=True)
    embed.add_field(name="üìÖ Created on", value=BOT_CREATED, inline=True)
    embed.add_field(name="üî¢ Version", value=BOT_VERSION, inline=True)
    embed.add_field(name="‚ú® Latest Update", value=BOT_UPDATE, inline=False)
    embed.add_field(name="üß† AI Features", value="‚Ä¢ Friendly chat companion (FREE Hugging Face AI)\n‚Ä¢ Smart content moderation\n‚Ä¢ Natural language help", inline=False)
    embed.set_footer(text="Made with ‚ù§Ô∏è for Champions of the Shattered Realm")
    await interaction.response.send_message(embed=embed)

@bot.tree.command(name="help", description="Show all commands")
async def help_command(interaction: discord.Interaction):
    embed = discord.Embed(
        title="üõ†Ô∏è CSR Bot Commands",
        description="Here's everything I can do!",
        color=discord.Color.green()
    )
    
    embed.add_field(name="üí¨ Chat with Me", value="Just say 'CSR' or mention me to chat!", inline=False)
    embed.add_field(name="üìä /aboutthisbot", value="Bot info & credits", inline=False)
    
    if staff_or_admin(interaction.user):
        embed.add_field(name="\n**üõ°Ô∏è Staff Commands**", value="_ _", inline=False)
        embed.add_field(name="/kick <member> <reason>", value="Kick a user", inline=False)
        embed.add_field(name="/ban <member> <reason>", value="Ban a user", inline=False)
        embed.add_field(name="/unban <user>", value="Unban a user", inline=False)
        embed.add_field(name="/mute <member> <reason>", value="Mute a user", inline=False)
        embed.add_field(name="/unmute <member>", value="Unmute a user", inline=False)
        embed.add_field(name="/chatfilter <on/off>", value="Toggle word filter", inline=False)
        embed.add_field(name="/aimod <on/off>", value="Toggle AI moderation", inline=False)
        embed.add_field(name="/announcement <channel> <msg>", value="Send announcement", inline=False)
    
    embed.add_field(name="/suggestions <message>", value="Send anonymous suggestion to staff", inline=False)
    embed.set_footer(text=f"CSR Bot v{BOT_VERSION} ‚Ä¢ Made by {BOT_AUTHOR}")
    await interaction.response.send_message(embed=embed)

@bot.tree.command(name="kick", description="Kick a member (Admin only)")
async def kick(interaction: discord.Interaction, member: discord.Member, reason: str):
    if not staff_or_admin(interaction.user):
        await interaction.response.send_message("‚ùå No permission", ephemeral=True)
        return
    try:
        await member.kick(reason=reason)
        await interaction.response.send_message(f"‚úÖ Kicked {member.mention}: {reason}", ephemeral=True)
    except Exception as e:
        await interaction.response.send_message(f"‚ùå Error: {e}", ephemeral=True)

@bot.tree.command(name="ban", description="Ban a member (Admin only)")
async def ban(interaction: discord.Interaction, member: discord.Member, reason: str):
    if not staff_or_admin(interaction.user):
        await interaction.response.send_message("‚ùå No permission", ephemeral=True)
        return
    try:
        await member.ban(reason=reason)
        await interaction.response.send_message(f"‚úÖ Banned {member.mention}: {reason}", ephemeral=True)
    except Exception as e:
        await interaction.response.send_message(f"‚ùå Error: {e}", ephemeral=True)

@bot.tree.command(name="unban", description="Unban a user (Admin only)")
async def unban(interaction: discord.Interaction, user: discord.User):
    if not staff_or_admin(interaction.user):
        await interaction.response.send_message("‚ùå No permission", ephemeral=True)
        return
    try:
        await interaction.guild.unban(user)
        await interaction.response.send_message(f"‚úÖ Unbanned {user.mention}", ephemeral=True)
    except Exception as e:
        await interaction.response.send_message(f"‚ùå Error: {e}", ephemeral=True)

@bot.tree.command(name="mute", description="Mute a member (Admin only)")
async def mute(interaction: discord.Interaction, member: discord.Member, reason: str):
    if not staff_or_admin(interaction.user):
        await interaction.response.send_message("‚ùå No permission", ephemeral=True)
        return
    
    mute_role = interaction.guild.get_role(MUTED_ROLE_ID)
    if not mute_role:
        await interaction.response.send_message("‚ùå Muted role not found!", ephemeral=True)
        return
    
    if mute_role in member.roles:
        await interaction.response.send_message(f"‚ö†Ô∏è {member.mention} is already muted", ephemeral=True)
        return
    
    try:
        await member.add_roles(mute_role, reason=reason)
        await interaction.response.send_message(f"‚úÖ Muted {member.mention}: {reason}", ephemeral=True)
    except Exception as e:
        await interaction.response.send_message(f"‚ùå Error: {e}", ephemeral=True)

@bot.tree.command(name="unmute", description="Unmute a member (Admin only)")
async def unmute(interaction: discord.Interaction, member: discord.Member):
    if not staff_or_admin(interaction.user):
        await interaction.response.send_message("‚ùå No permission", ephemeral=True)
        return
    
    mute_role = interaction.guild.get_role(MUTED_ROLE_ID)
    if not mute_role:
        await interaction.response.send_message("‚ùå Muted role not found!", ephemeral=True)
        return
    
    if mute_role not in member.roles:
        await interaction.response.send_message(f"‚ö†Ô∏è {member.mention} is not muted", ephemeral=True)
        return
    
    try:
        await member.remove_roles(mute_role)
        await interaction.response.send_message(f"‚úÖ Unmuted {member.mention}", ephemeral=True)
    except Exception as e:
        await interaction.response.send_message(f"‚ùå Error: {e}", ephemeral=True)

@bot.tree.command(name="announcement", description="Send announcement (Staff only)")
async def announcement(interaction: discord.Interaction, channel: discord.TextChannel, message: str):
    if not staff_or_admin(interaction.user):
        await interaction.response.send_message("‚ùå No permission", ephemeral=True)
        return
    try:
        await channel.send(message)
        await interaction.response.send_message(f"‚úÖ Announcement sent to {channel.mention}", ephemeral=True)
    except Exception as e:
        await interaction.response.send_message(f"‚ùå Error: {e}", ephemeral=True)

@bot.tree.command(name="suggestions", description="Send anonymous suggestion to staff")
async def suggestions(interaction: discord.Interaction, message: str):
    channel = interaction.guild.get_channel(MODLOG_CHANNEL_ID)
    staff_role = interaction.guild.get_role(CSR_STAFF_ROLE_ID)
    
    embed = discord.Embed(
        title="üí° New Suggestion",
        description=message,
        color=discord.Color.blue()
    )
    embed.set_footer(text=f"From: {interaction.user.name}")
    
    await channel.send(f"{staff_role.mention}", embed=embed)
    await interaction.response.send_message("‚úÖ Suggestion sent to staff!", ephemeral=True)

# --- RUN BOT ---
if __name__ == "__main__":
    bot.run(TOKEN)
