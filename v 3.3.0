from dotenv import load_dotenv
load_dotenv()

import discord
import aiohttp
import asyncio
import datetime
import pytz
import re
import os
import json
import random
from discord.ext import commands, tasks
from discord import ui
from bs4 import BeautifulSoup
from youtube_transcript_api import YouTubeTranscriptApi
from googleapiclient.discovery import build
from googletrans import Translator

# --- CONFIGURATION ---
TOKEN = os.getenv('DISCORD_BOT_TOKEN')
HF_TOKEN = os.getenv('HF_TOKEN')
YOUTUBE_API_KEY = os.getenv('YOUTUBE_API_KEY')

if not TOKEN:
    raise ValueError("DISCORD_BOT_TOKEN environment variable is required!")

CHANNEL_ID = 1432803218919919666
GROUP_ID = '1003228779'
GUILD_IMAGE = 'https://tr.rbxcdn.com/180DAY-929c99c9ad05b139c8851f873606876e/150/150/Image/Webp/noFilter'
UPDATE_INTERVAL = 300
CSR_STAFF_ROLE_ID = 1430084386837102673
MODLOG_CHANNEL_ID = 1429402899649134664
DAILYCHECKS = 1433403158612279327
CSR_EMOJI = "<:CSR:1432804739447263333>"
MUTED_ROLE_ID = 1433893267816054844

# Verification settings
VERIFICATION_CHANNEL_ID = 1433909897749073931
HELP_CHANNEL_ID = 1434121366008889457
VERIFICATION_PENDING_ROLE_ID = 1425155127530225767
MEMBER_APPROVED_ROLE_ID = 1425144091762495631
VISITOR_ROLE_ID = 1433907795593531513

# Wiki & YouTube URLs
SBOR_WIKI_URL = "https://swordbloxonlinerebirth.fandom.com"
BLOXFRUITS_WIKI_URL = "https://blox-fruits.fandom.com"
YOUTUBE_CHANNEL_ID = "UC75x60utxCnFWRPDsUIdsWA"

BOT_VERSION = "3.2.0"
BOT_UPDATE = "NEW: Timezone settings, Command shortcuts (csr help), Fixed moderation, More languages"
BOT_AUTHOR = "kikusuka"
BOT_CREATED = "October 24, 2025"

# --- TRANSLATION SETUP ---
translator = Translator()

SUPPORTED_LANGUAGES = {
    'en': 'üá∫üá∏ English',
    'es': 'üá™üá∏ Espa√±ol',
    'fr': 'üá´üá∑ Fran√ßais',
    'de': 'üá©üá™ Deutsch',
    'pt': 'üáµüáπ Portugu√™s',
    'it': 'üáÆüáπ Italiano',
    'ja': 'üáØüáµ Êó•Êú¨Ë™û',
    'ko': 'üá∞üá∑ ÌïúÍµ≠Ïñ¥',
    'zh-cn': 'üá®üá≥ ‰∏≠Êñá',
    'hi': 'üáÆüá≥ ‡§π‡§ø‡§®‡•ç‡§¶‡•Ä',
    'te': 'üáÆüá≥ ‡∞§‡±Ü‡∞≤‡±Å‡∞ó‡±Å',
    'vi': 'üáªüá≥ Ti·∫øng Vi·ªát',
    'ar': 'üá∏üá¶ ÿßŸÑÿπÿ±ÿ®Ÿäÿ©',
    'ru': 'üá∑üá∫ –†—É—Å—Å–∫–∏–π',
    'tr': 'üáπüá∑ T√ºrk√ße',
    'nl': 'üá≥üá± Nederlands',
    'pl': 'üáµüá± Polski',
    'id': 'üáÆüá© Bahasa Indonesia',
    'th': 'üáπüá≠ ‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢',
    'ms': 'üá≤üáæ Bahasa Melayu'
}

# Popular timezones
SUPPORTED_TIMEZONES = {
    'UTC': 'UTC (Coordinated Universal Time)',
    'America/New_York': 'EST/EDT (US East)',
    'America/Chicago': 'CST/CDT (US Central)',
    'America/Denver': 'MST/MDT (US Mountain)',
    'America/Los_Angeles': 'PST/PDT (US West)',
    'Europe/London': 'GMT/BST (UK)',
    'Europe/Paris': 'CET/CEST (Central Europe)',
    'Europe/Moscow': 'MSK (Moscow)',
    'Asia/Dubai': 'GST (Dubai/UAE)',
    'Asia/Kolkata': 'IST (India)',
    'Asia/Shanghai': 'CST (China)',
    'Asia/Tokyo': 'JST (Japan)',
    'Asia/Seoul': 'KST (South Korea)',
    'Asia/Singapore': 'SGT (Singapore)',
    'Australia/Sydney': 'AEDT/AEST (Sydney)',
    'Pacific/Auckland': 'NZDT/NZST (New Zealand)'
}

# Game detection keywords
SBOR_KEYWORDS = ['sbor', 'sword', 'blade', 'swordblox', 'sword blox', 'online rebirth', 'iron ore', 'angels dust', 'weapon']
BLOXFRUITS_KEYWORDS = ['blox', 'fruit', 'devil', 'blox fruits', 'bf', 'dough', 'leopard', 'awakening']

# --- DATA STORAGE ---
DATA_DIR = "data"
CACHE_DIR = ".cache"
LOCAL_DIR = ".local"

for directory in [DATA_DIR, CACHE_DIR, LOCAL_DIR]:
    os.makedirs(directory, exist_ok=True)

SBOR_WIKI_FILE = f"{DATA_DIR}/sbor_wiki.json"
BLOXFRUITS_WIKI_FILE = f"{DATA_DIR}/bloxfruits_wiki.json"
YOUTUBE_DATA_FILE = f"{DATA_DIR}/youtube_transcripts.json"
GUILD_FAQS_FILE = f"{DATA_DIR}/guild_faqs.json"
MODERATION_STATS_FILE = f"{DATA_DIR}/moderation_stats.json"
USER_SETTINGS_FILE = f"{DATA_DIR}/user_settings.json"

# --- HELPER FUNCTIONS ---
def load_or_create_file(filepath, default_data):
    if os.path.exists(filepath):
        with open(filepath, 'r', encoding='utf-8') as f:
            return json.load(f)
    else:
        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(default_data, f, indent=2)
        return default_data

def save_json(filepath, data):
    with open(filepath, 'w', encoding='utf-8') as f:
        json.dump(data, f, indent=2, ensure_ascii=False)

# Initialize data files
SBOR_WIKI_DATA = load_or_create_file(SBOR_WIKI_FILE, {"pages": {}, "last_update": None})
BLOXFRUITS_WIKI_DATA = load_or_create_file(BLOXFRUITS_WIKI_FILE, {"pages": {}, "last_update": None})
YOUTUBE_DATA = load_or_create_file(YOUTUBE_DATA_FILE, {"videos": {}, "last_update": None})
GUILD_FAQS = load_or_create_file(GUILD_FAQS_FILE, {
    "faqs": [
        {"id": 1, "question": "What is CSR?", "answer": "CSR = Champions of the Shattered Realm! We're a multi-game guild for Roblox, SBOR, Blox Fruits & more!", "keywords": ["what is csr", "about csr", "csr guild"]}
    ],
    "next_id": 2
})
MODERATION_STATS = load_or_create_file(MODERATION_STATS_FILE, {
    "total_messages_deleted": 0,
    "regex_catches": 0,
    "ai_catches": 0,
    "last_reset": datetime.datetime.utcnow().isoformat()
})
USER_SETTINGS = load_or_create_file(USER_SETTINGS_FILE, {})

# Bad words
def load_bad_words(filepath="badwords.txt"):
    if not os.path.exists(filepath):
        with open(filepath, "w") as f:
            f.write("# Add bad words here, one per line\n")
        return set()
    with open(filepath, "r") as f:
        words = [line.strip().lower() for line in f if line.strip() and not line.startswith("#")]
    return set(words)

BAD_WORDS = load_bad_words()
BAD_WORDS_REGEX = re.compile(r"\b(" + "|".join(map(re.escape, BAD_WORDS)) + r")\b", re.IGNORECASE) if BAD_WORDS else None
CHAT_FILTER_ENABLED = True
AI_MODERATION_ENABLED = True

intents = discord.Intents.default()
intents.members = True
intents.message_content = True
bot = commands.Bot(command_prefix="/", intents=intents)

# --- USER SETTINGS FUNCTIONS ---
def get_user_language(user_id):
    """Get user's preferred language (default: English)"""
    return USER_SETTINGS.get(str(user_id), {}).get('language', 'en')

def set_user_language(user_id, language):
    """Set user's preferred language"""
    if str(user_id) not in USER_SETTINGS:
        USER_SETTINGS[str(user_id)] = {}
    USER_SETTINGS[str(user_id)]['language'] = language
    save_json(USER_SETTINGS_FILE, USER_SETTINGS)

def get_user_timezone(user_id):
    """Get user's preferred timezone (default: UTC)"""
    return USER_SETTINGS.get(str(user_id), {}).get('timezone', 'UTC')

def set_user_timezone(user_id, timezone):
    """Set user's preferred timezone"""
    if str(user_id) not in USER_SETTINGS:
        USER_SETTINGS[str(user_id)] = {}
    USER_SETTINGS[str(user_id)]['timezone'] = timezone
    save_json(USER_SETTINGS_FILE, USER_SETTINGS)

def format_time_for_user(dt, user_id):
    """Convert datetime to user's timezone"""
    user_tz = get_user_timezone(user_id)
    try:
        tz = pytz.timezone(user_tz)
        if dt.tzinfo is None:
            dt = pytz.utc.localize(dt)
        local_time = dt.astimezone(tz)
        return local_time.strftime('%Y-%m-%d %H:%M %Z')
    except:
        return dt.strftime('%Y-%m-%d %H:%M UTC')

async def translate_text(text, target_lang):
    """Translate text to target language"""
    if target_lang == 'en':
        return text
    
    try:
        translated = translator.translate(text, dest=target_lang)
        return translated.text
    except Exception as e:
        print(f"Translation error: {e}")
        return text

def detect_game(message):
    """Smart game detection from message"""
    msg_lower = message.lower()
    
    sbor_score = sum(1 for keyword in SBOR_KEYWORDS if keyword in msg_lower)
    blox_score = sum(1 for keyword in BLOXFRUITS_KEYWORDS if keyword in msg_lower)
    
    if sbor_score > blox_score:
        return 'sbor'
    elif blox_score > sbor_score:
        return 'bloxfruits'
    else:
        return None

# --- LIGHTWEIGHT WIKI FETCHER (FETCH ALL PAGES) ---
async def fetch_wiki_pages(wiki_base_url, wiki_name, old_pages=None, max_pages=None):
    """Fetch ALL pages from wiki using MediaWiki API"""
    print(f"üï∑Ô∏è Fetching {wiki_name}...")
    pages = dict(old_pages) if old_pages else {}
    new_count = 0
    
    try:
        api_url = f"{wiki_base_url}/api.php"
        connector = aiohttp.TCPConnector(limit=5)
        timeout = aiohttp.ClientTimeout(total=30)
        
        async with aiohttp.ClientSession(connector=connector, timeout=timeout) as session:
            # Fetch ALL pages with pagination
            apcontinue = None
            total_fetched = 0
            
            while True:
                params = {
                    "action": "query",
                    "list": "allpages",
                    "aplimit": 500,  # Max allowed by API
                    "format": "json"
                }
                
                if apcontinue:
                    params["apcontinue"] = apcontinue
                
                async with session.get(api_url, params=params) as response:
                    if response.status != 200:
                        break
                    
                    data = await response.json()
                    all_pages = data.get('query', {}).get('allpages', [])
                    total_fetched += len(all_pages)
                    
                    print(f"üìÑ Fetched {len(all_pages)} pages (Total: {total_fetched})")
                    
                    for i, page_data in enumerate(all_pages):
                        title = page_data['title']
                        title_lower = title.lower()
                        
                        # Skip if recently scraped
                        if title_lower in pages:
                            last_scraped = datetime.datetime.fromisoformat(pages[title_lower]['scraped'])
                            if (datetime.datetime.utcnow() - last_scraped).days < 30:
                                continue
                        
                        # Fetch page content
                        content_params = {
                            "action": "query",
                            "titles": title,
                            "prop": "extracts|pageimages",
                            "exintro": True,
                            "explaintext": True,
                            "piprop": "thumbnail",
                            "pithumbsize": 300,
                            "format": "json"
                        }
                        
                        try:
                            async with session.get(api_url, params=content_params) as page_resp:
                                if page_resp.status == 200:
                                    page_json = await page_resp.json()
                                    page_info = next(iter(page_json.get('query', {}).get('pages', {}).values()), {})
                                    
                                    extract = page_info.get('extract', '')
                                    thumbnail = page_info.get('thumbnail', {}).get('source')
                                    
                                    pages[title_lower] = {
                                                'title': title,
                                                'url': f"{wiki_base_url}/wiki/{title.replace(' ', '_')}",
                                                'content': extract[:500] if extract else "",
                                                'image': thumbnail,
                                                'scraped': datetime.datetime.utcnow().isoformat()
                                    }
                                    new_count += 1

                        except:
                            continue
                        
                        await asyncio.sleep(0.3)  # Rate limiting
                    
                    # Check if there are more pages
                    if 'continue' in data and 'apcontinue' in data['continue']:
                        apcontinue = data['continue']['apcontinue']
                        await asyncio.sleep(1)  # Pause between page batches
                    else:
                        break
                    
                    # Stop if max_pages limit reached
                    if max_pages and total_fetched >= max_pages:
                        break
        
        print(f"‚úÖ Done! Total: {len(pages)} | New: {new_count}")
    except Exception as e:
        print(f"‚ùå Error: {e}")
    
    return pages

# --- YOUTUBE FETCHER ---
async def fetch_youtube_channel():
    print("üé• Fetching YouTube...")
    videos = {}
    
    if not YOUTUBE_API_KEY:
        print("‚ö†Ô∏è No YouTube API key")
        return videos
    
    try:
        youtube = build('youtube', 'v3', developerKey=YOUTUBE_API_KEY)
        request = youtube.channels().list(part='contentDetails', id=YOUTUBE_CHANNEL_ID)
        response = request.execute()
        
        if not response['items']:
            return videos
        
        uploads_playlist = response['items'][0]['contentDetails']['relatedPlaylists']['uploads']
        videos_request = youtube.playlistItems().list(part='snippet', playlistId=uploads_playlist, maxResults=25)
        videos_response = videos_request.execute()
        
        for item in videos_response['items']:
            video_id = item['snippet']['resourceId']['videoId']
            video_title = item['snippet']['title']
            video_url = f"https://www.youtube.com/watch?v={video_id}"
            
            try:
                transcript_list = YouTubeTranscriptApi.get_transcript(video_id)
                transcript_text = ' '.join([t['text'] for t in transcript_list])
                videos[video_id] = {
                    'title': video_title,
                    'url': video_url,
                    'transcript': transcript_text[:1500],
                    'scraped': datetime.datetime.utcnow().isoformat()
                }
            except:
                continue
        
        print(f"‚úÖ Got {len(videos)} videos")
    except Exception as e:
        print(f"‚ùå Error: {e}")
    
    return videos

# --- AUTO UPDATE ---
@tasks.loop(hours=168)
async def auto_update_data():
    now = datetime.datetime.utcnow()
    target_hour = 3
    
    if now.hour >= target_hour:
        next_run = (now + datetime.timedelta(days=1)).replace(hour=target_hour, minute=0, second=0, microsecond=0)
    else:
        next_run = now.replace(hour=target_hour, minute=0, second=0, microsecond=0)
    
    wait_seconds = (next_run - now).total_seconds()
    print(f"‚è∞ Next update: {next_run.strftime('%Y-%m-%d %H:%M UTC')} (in {wait_seconds/3600:.1f}h)")
    await asyncio.sleep(wait_seconds)
    
    print("\nüîÑ Weekly update starting...")
    
    sbor_pages = await fetch_wiki_pages(SBOR_WIKI_URL, "SBOR", SBOR_WIKI_DATA.get('pages', {}))
    SBOR_WIKI_DATA['pages'] = sbor_pages
    SBOR_WIKI_DATA['last_update'] = datetime.datetime.utcnow().isoformat()
    save_json(SBOR_WIKI_FILE, SBOR_WIKI_DATA)
    
    await asyncio.sleep(2)
    
    blox_pages = await fetch_wiki_pages(BLOXFRUITS_WIKI_URL, "Blox Fruits", BLOXFRUITS_WIKI_DATA.get('pages', {}))
    BLOXFRUITS_WIKI_DATA['pages'] = blox_pages
    BLOXFRUITS_WIKI_DATA['last_update'] = datetime.datetime.utcnow().isoformat()
    save_json(BLOXFRUITS_WIKI_FILE, BLOXFRUITS_WIKI_DATA)
    
    await asyncio.sleep(2)
    
    youtube_vids = await fetch_youtube_channel()
    YOUTUBE_DATA['videos'] = youtube_vids
    YOUTUBE_DATA['last_update'] = datetime.datetime.utcnow().isoformat()
    save_json(YOUTUBE_DATA_FILE, YOUTUBE_DATA)
    
    print("‚úÖ Update complete!\n")

@auto_update_data.before_loop
async def before_auto_update():
    await bot.wait_until_ready()

# --- HELPER FUNCTIONS ---
def staff_or_admin(user):
    if not hasattr(user, 'roles'):
        return False
    return any(r.id == CSR_STAFF_ROLE_ID for r in user.roles) or user.guild_permissions.administrator

def admin_only(interaction):
    try:
        return interaction.user.guild_permissions.administrator
    except:
        return False

async def get_member_count(group_id):
    try:
        url = f"https://groups.roblox.com/v1/groups/{group_id}"
        async with aiohttp.ClientSession() as session:
            async with session.get(url, timeout=10) as response:
                if response.status == 200:
                    data = await response.json()
                    return data.get("memberCount", "Error")
    except:
        pass
    return "Error"

async def get_roblox_user_info(user_id):
    try:
        url = f"https://users.roblox.com/v1/users/{user_id}"
        async with aiohttp.ClientSession() as session:
            async with session.get(url, timeout=10) as response:
                if response.status == 200:
                    data = await response.json()
                    username = data.get("name", "Unknown")
                    display_name = data.get("displayName", username)
                    return username, display_name
    except:
        pass
    return None, None

async def update_nickname(member, roblox_username, display_name=None):
    try:
        nickname = f"{display_name} (@{roblox_username})" if display_name and display_name != roblox_username else roblox_username
        await member.edit(nick=nickname)
        return True
    except:
        return False

# --- SMART SEARCH ---
def search_faqs(query):
    query_lower = query.lower()
    for faq in GUILD_FAQS['faqs']:
        if any(keyword in query_lower for keyword in faq['keywords']):
            return faq['answer'], None, False
    return None, None, False

def search_wiki(query, wiki_data, wiki_name):
    query_lower = query.lower()
    query_words = set(query_lower.split())
    
    best_match = None
    best_score = 0
    
    for page_key, page_data in list(wiki_data['pages'].items())[:500]:  # Increased search range
        score = 0
        
        if query_lower == page_key:
            return page_data, True
        
        if query_lower in page_key:
            score += 20
        
        if any(word in page_key for word in query_words):
            score += 10
        
        if any(word in page_data['content'].lower() for word in query_words):
            score += 2
        
        if score > best_score:
            best_score = score
            best_match = page_data
    
    if best_match and best_score > 5:
        return best_match, True
    
    return None, False

def search_youtube(query):
    query_lower = query.lower()
    matches = []
    
    for video_id, video_data in YOUTUBE_DATA['videos'].items():
        if video_data['transcript']:
            if query_lower in video_data['title'].lower() or query_lower in video_data['transcript'].lower():
                matches.append((video_data['title'], video_data['url']))
    
    return matches[:3]

# --- AI CHAT WITH AUTO-TRANSLATION ---
async def chat_with_ai(message, user_id, channel_id):
    msg_lower = message.lower()
    user_lang = get_user_language(user_id)
    
    # Casual greetings
    greeting_words = ["hi", "hello", "hey", "sup", "yo", "hola", "bonjour", "hallo", "ciao", "namaste", "wassup", "what's up"]
    if any(word in msg_lower for word in greeting_words) and len(msg_lower) < 30:
        responses = ["Hey! What's good? üëã", "Hello! How can I help? üòä", "Yo! Need something?", "Hi there! Ready to game? üéÆ"]
        response = random.choice(responses)
        return await translate_text(response, user_lang), None, False
    
    # Bot status check
    status_words = ["you ok", "you there", "you alive", "are you ok", "u ok", "you good"]
    if any(word in msg_lower for word in status_words):
        responses = ["Yeah, I'm here! What's up? üòä", "All good! How can I help? üí™", "Yep, ready to assist! üéÆ", "I'm online and ready! What do you need? üî•"]
        response = random.choice(responses)
        return await translate_text(response, user_lang), None, False
    
    # Thanks
    if any(word in msg_lower for word in ["thanks", "thank you", "thx", "tysm", "appreciate"]):
        responses = ["No problem! üòä", "You're welcome! üéâ", "Anytime!", "Glad I could help! üí™"]
        response = random.choice(responses)
        return await translate_text(response, user_lang), None, False
    
    # Goodbye
    if any(word in msg_lower for word in ["bye", "goodbye", "cya", "see ya", "later"]):
        responses = ["See ya! üëã", "Later! üéÆ", "Catch you later!", "Peace! ‚úåÔ∏è"]
        response = random.choice(responses)
        return await translate_text(response, user_lang), None, False
    
    # Encouragement
    if any(word in msg_lower for word in ["level up", "grind", "tired", "hard", "difficult", "struggle"]):
        responses = ["You got this! üí™", "Keep grinding! üî•", "Stay awesome! ‚≠ê", "You're doing great! üéâ"]
        response = random.choice(responses)
        return await translate_text(response, user_lang), None, False
    
    # Creator
    if "who made" in msg_lower or "who created" in msg_lower:
        response = f"I was created by **{BOT_AUTHOR}** (kiku)! üõ†Ô∏è"
        return await translate_text(response, user_lang), None, False
    
    # FAQ search
    faq_answer, _, _ = search_faqs(message)
    if faq_answer:
        return await translate_text(faq_answer, user_lang), None, False
    
    # SMART GAME DETECTION
    detected_game = detect_game(message)
    
    if detected_game == 'sbor':
        result, found = search_wiki(message, SBOR_WIKI_DATA, "SBOR")
        if found:
            return result, "sbor", True
    elif detected_game == 'bloxfruits':
        result, found = search_wiki(message, BLOXFRUITS_WIKI_DATA, "Blox Fruits")
        if found:
            return result, "bloxfruits", True
    
    if not detected_game or not found:
        result, found = search_wiki(message, SBOR_WIKI_DATA, "SBOR")
        if found:
            return result, "sbor", True
        
        result, found = search_wiki(message, BLOXFRUITS_WIKI_DATA, "Blox Fruits")
        if found:
            return result, "bloxfruits", True
    
    # YouTube search
    if any(word in msg_lower for word in ["video", "guide", "tutorial", "how to"]):
        video_matches = search_youtube(message)
        if video_matches:
            response = "Check out these videos:\n"
            for title, url in video_matches:
                response += f"‚Ä¢ [{title[:50]}...]({url})\n"
            return await translate_text(response, user_lang), None, False
    
    # Default
    response = "Not sure about that! Try asking staff in the help channel! ü§î"
    return await translate_text(response, user_lang), None, False

# --- AI MODERATION (LESS AGGRESSIVE) ---
async def check_message_with_ai(message_content):
    if not AI_MODERATION_ENABLED:
        return False, None
    
    # Only catch VERY toxic patterns (reduced sensitivity)
    toxic_patterns = [r'\bkys\b', r'kill yourself', r'hang yourself']
    for pattern in toxic_patterns:
        if re.search(pattern, message_content.lower()):
            return True, "Severe toxic pattern detected"
    
    if not HF_TOKEN:
        return False, None
    
    try:
        API_URL = "https://api-inference.huggingface.co/models/unitary/toxic-bert"
        headers = {"Authorization": f"Bearer {HF_TOKEN}"}
        
        async with aiohttp.ClientSession() as session:
            async with session.post(API_URL, headers=headers, json={"inputs": message_content}, timeout=aiohttp.ClientTimeout(total=5)) as response:
                if response.status != 200:
                    return False, None
                
                result = await response.json()
                
                if isinstance(result, list) and len(result) > 0:
                    for item in result[0]:
                        label = item.get('label', '').lower()
                        score = item.get('score', 0)
                        
                        # Only catch SEVERE toxicity (increased threshold to 0.9)
                        toxic_labels = ['severe_toxic', 'threat']
                        if label in toxic_labels and score > 0.9:
                            return True, f"AI: {label} ({score:.0%})"
    except:
        pass
    
    return False, None

# --- SETTINGS VIEW ---
class SettingsView(ui.View):
    def __init__(self, user_id):
        super().__init__(timeout=180)
        self.user_id = user_id
    
    @ui.button(label="üåç Language", style=discord.ButtonStyle.primary)
    async def language_button(self, interaction: discord.Interaction, button: ui.Button):
        view = LanguageSelectView(self.user_id)
        current_lang = get_user_language(self.user_id)
        
        embed = discord.Embed(
            title="üåç Language Settings",
            description=f"**Current:** {SUPPORTED_LANGUAGES.get(current_lang, 'üá∫üá∏ English')}\n\nSelect below:",
            color=discord.Color.blue()
        )
        
        await interaction.response.send_message(embed=embed, view=view, ephemeral=True)
    
    @ui.button(label="‚è∞ Timezone", style=discord.ButtonStyle.secondary)
    async def timezone_button(self, interaction: discord.Interaction, button: ui.Button):
        view = TimezoneSelectView(self.user_id)
        current_tz = get_user_timezone(self.user_id)
        
        embed = discord.Embed(
            title="‚è∞ Timezone Settings",
            description=f"**Current:** {SUPPORTED_TIMEZONES.get(current_tz, 'UTC')}\n\nSelect below:",
            color=discord.Color.blue()
        )
        
        await interaction.response.send_message(embed=embed, view=view, ephemeral=True)

class LanguageSelectView(ui.View):
    def __init__(self, user_id):
        super().__init__(timeout=120)
        self.user_id = user_id
        
        # Split languages into chunks of 25 (Discord limit)
        lang_items = list(SUPPORTED_LANGUAGES.items())
        chunk_size = 25
        
        for i in range(0, len(lang_items), chunk_size):
            chunk = lang_items[i:i+chunk_size]
            options = [discord.SelectOption(label=name, value=code, emoji=name.split()[0]) 
                       for code, name in chunk]
            
            select = ui.Select(placeholder=f"Choose language ({i//chunk_size + 1})...", options=options, custom_id=f"lang_select_{i}")
            select.callback = self.language_callback
            self.add_item(select)
    
    async def language_callback(self, interaction: discord.Interaction):
        selected_lang = interaction.data['values'][0]
        set_user_language(self.user_id, selected_lang)
        
        confirmation = f"‚úÖ Language changed to **{SUPPORTED_LANGUAGES[selected_lang]}**!"
        translated = await translate_text(confirmation, selected_lang)
        
        await interaction.response.send_message(translated, ephemeral=True)
        self.stop()

class TimezoneSelectView(ui.View):
    def __init__(self, user_id):
        super().__init__(timeout=120)
        self.user_id = user_id
        
        options = [discord.SelectOption(label=name, value=code) 
                   for code, name in SUPPORTED_TIMEZONES.items()]
        
        select = ui.Select(placeholder="Choose your timezone...", options=options, custom_id="tz_select")
        select.callback = self.timezone_callback
        self.add_item(select)
    
    async def timezone_callback(self, interaction: discord.Interaction):
        selected_tz = interaction.data['values'][0]
        set_user_timezone(self.user_id, selected_tz)
        
        now = datetime.datetime.utcnow()
        formatted_time = format_time_for_user(now, self.user_id)
        
        await interaction.response.send_message(
            f"‚úÖ Timezone changed to **{SUPPORTED_TIMEZONES[selected_tz]}**!\n\n"
            f"üïê Current time in your timezone: **{formatted_time}**",
            ephemeral=True
        )
        self.stop()

# --- VERIFICATION SYSTEM ---
class CaptchaModal(ui.Modal, title="Human Verification"):
    def __init__(self, answer):
        super().__init__()
        self.correct_answer = answer
        
    captcha_answer = ui.TextInput(label="Answer the math problem", placeholder="Enter the answer", required=True, max_length=10)
    roblox_id = ui.TextInput(label="Your Roblox User ID", placeholder="Example: 123456789", required=True, max_length=20)
    
    async def on_submit(self, interaction: discord.Interaction):
        user_answer = self.captcha_answer.value.strip()
        user_id = self.roblox_id.value.strip()
        
        if user_answer != str(self.correct_answer):
            await interaction.response.send_message("‚ùå Wrong captcha!", ephemeral=True)
            return
        
        if not user_id.isdigit():
            await interaction.response.send_message("‚ùå Invalid User ID!", ephemeral=True)
            return
        
        await interaction.response.defer(ephemeral=True)
        
        username, display_name = await get_roblox_user_info(user_id)
        
        if not username:
            await interaction.followup.send("‚ùå User ID not found!", ephemeral=True)
            return
        
        await update_nickname(interaction.user, username, display_name)
        
        display_text = f"{display_name} (@{username})" if display_name != username else username
        view = MemberVisitorView(username, display_name, user_id, interaction.user)
        
        await interaction.followup.send(
            f"‚úÖ **Verified!**\n**Roblox:** {display_text}\n**ID:** {user_id}\n\nAre you a **CSR Member** or **Visitor**?",
            view=view,
            ephemeral=True
        )

class VerificationStartView(ui.View):
    def __init__(self):
        super().__init__(timeout=None)
    
    @ui.button(label="üîê Get Verified", style=discord.ButtonStyle.green, custom_id="start_verify_captcha")
    async def start_verification(self, interaction: discord.Interaction, button: ui.Button):
        num1, num2 = random.randint(1, 20), random.randint(1, 20)
        operation = random.choice(["+", "-", "*"])
        answer = eval(f"{num1}{operation}{num2}")
        
        modal = CaptchaModal(answer)
        modal.captcha_answer.label = f"What is {num1} {operation} {num2}?"
        await interaction.response.send_modal(modal)

class MemberVisitorView(ui.View):
    def __init__(self, roblox_username, display_name, roblox_id, user):
        super().__init__(timeout=120)
        self.roblox_username = roblox_username
        self.display_name = display_name
        self.roblox_id = roblox_id
        self.user = user
    
    @ui.button(label="üè∞ CSR Member", style=discord.ButtonStyle.primary)
    async def member_button(self, interaction: discord.Interaction, button: ui.Button):
        await interaction.response.send_message("Upload a screenshot of your SBOR guild page (3 minutes).", ephemeral=True)
        
        def check(m):
            return m.author.id == interaction.user.id and m.attachments and isinstance(m.channel, discord.DMChannel)
        
        try:
            screenshot_msg = await bot.wait_for('message', timeout=180, check=check)
            
            modlog = bot.get_channel(MODLOG_CHANNEL_ID)
            embed = discord.Embed(
                title="üî∞ Member Verification",
                description=f"**User:** {self.user.mention}\n**Roblox:** {self.roblox_username} (@{self.display_name})\n**ID:** {self.roblox_id}",
                color=discord.Color.blue()
            )
            embed.set_image(url=screenshot_msg.attachments[0].url)
            
            approval_view = StaffApprovalView(self.user, "member", self.roblox_username, self.roblox_id)
            await modlog.send(f"<@&{CSR_STAFF_ROLE_ID}>", embed=embed, view=approval_view)
            await interaction.user.send("‚úÖ Sent to staff!")
        except asyncio.TimeoutError:
            await interaction.user.send("‚è∞ Timeout!")
    
    @ui.button(label="üë§ Visitor", style=discord.ButtonStyle.secondary)
    async def visitor_button(self, interaction: discord.Interaction, button: ui.Button):
        await interaction.response.send_message("What guild are you from? (1 minute)", ephemeral=True)
        
        def check(m):
            return m.author.id == interaction.user.id and isinstance(m.channel, discord.DMChannel)
        
        try:
            guild_msg = await bot.wait_for('message', timeout=60, check=check)
            visitor_guild = guild_msg.content.strip()
            
            modlog = bot.get_channel(MODLOG_CHANNEL_ID)
            embed = discord.Embed(
                title="üë§ Visitor Verification",
                description=f"**User:** {self.user.mention}\n**Roblox:** {self.roblox_username}\n**Guild:** {visitor_guild}",
                color=discord.Color.green()
            )
            
            approval_view = StaffApprovalView(self.user, "visitor", self.roblox_username, self.roblox_id)
            await modlog.send(f"<@&{CSR_STAFF_ROLE_ID}>", embed=embed, view=approval_view)
            await interaction.user.send("‚úÖ Sent to staff!")
        except asyncio.TimeoutError:
            await interaction.user.send("‚è∞ Timeout!")

class StaffApprovalView(ui.View):
    def __init__(self, user, user_type, roblox_username, roblox_id):
        super().__init__(timeout=None)
        self.user = user
        self.user_type = user_type
        self.roblox_username = roblox_username
        self.roblox_id = roblox_id
    
    @ui.button(label="‚úÖ Approve", style=discord.ButtonStyle.success, custom_id="approve_verify")
    async def approve_button(self, interaction: discord.Interaction, button: ui.Button):
        if not staff_or_admin(interaction.user):
            await interaction.response.send_message("‚ùå Staff only!", ephemeral=True)
            return
        
        guild = interaction.guild
        member = guild.get_member(self.user.id)
        
        if not member:
            await interaction.response.send_message("‚ùå User not found!", ephemeral=True)
            return
        
        role_id = MEMBER_APPROVED_ROLE_ID if self.user_type == "member" else VISITOR_ROLE_ID
        role = guild.get_role(role_id)
        await member.add_roles(role)
        
        pending = guild.get_role(VERIFICATION_PENDING_ROLE_ID)
        if pending and pending in member.roles:
            await member.remove_roles(pending)
        
        await self.user.send(f"üéâ Verified as {self.user_type}! Welcome to CSR!")
        await interaction.response.send_message("‚úÖ Approved!", ephemeral=True)
        
        for item in self.children:
            item.disabled = True
        await interaction.message.edit(view=self)
    
    @ui.button(label="‚ùå Deny", style=discord.ButtonStyle.danger, custom_id="deny_verify")
    async def deny_button(self, interaction: discord.Interaction, button: ui.Button):
        if not staff_or_admin(interaction.user):
            await interaction.response.send_message("‚ùå Staff only!", ephemeral=True)
            return
        
        await self.user.send("‚ùå Verification denied. Contact staff!")
        await interaction.response.send_message("‚ùå Denied", ephemeral=True)
        
        for item in self.children:
            item.disabled = True
        await interaction.message.edit(view=self)

# --- STARTUP ---
@bot.event
async def on_ready():
    print(f"üöÄ CSR Bot v{BOT_VERSION} ONLINE!")
    print(f"üë§ {bot.user}")
    print(f"üìö SBOR: {len(SBOR_WIKI_DATA['pages'])} pages")
    print(f"üçé Blox Fruits: {len(BLOXFRUITS_WIKI_DATA['pages'])} pages")
    print(f"üé• YouTube: {len(YOUTUBE_DATA['videos'])} videos")
    print(f"üí° FAQs: {len(GUILD_FAQS['faqs'])}")
    print(f"üåç Languages: {len(SUPPORTED_LANGUAGES)}")
    print(f"‚è∞ Timezones: {len(SUPPORTED_TIMEZONES)}")
    
    bot.add_view(VerificationStartView())
    bot.add_view(StaffApprovalView(None, None, None, None))
    
    try:
        synced = await bot.tree.sync()
        print(f"‚ö° Synced {len(synced)} commands")
    except Exception as e:
        print(f"‚ùå Sync error: {e}")
    
    if not auto_update_data.is_running():
        auto_update_data.start()
    
    bot.loop.create_task(setup_verification_channel())
    bot.loop.create_task(update_permanent_message())
    bot.loop.create_task(daily_check())
    
    if not SBOR_WIKI_DATA['pages'] and not BLOXFRUITS_WIKI_DATA['pages']:
        print("\n‚ö†Ô∏è No wiki data! Use /forcefetch to scrape wikis.")
    else:
        print(f"‚úÖ Data loaded successfully!")

async def setup_verification_channel():
    await bot.wait_until_ready()
    channel = bot.get_channel(VERIFICATION_CHANNEL_ID)
    if not channel:
        return
    
    async for msg in channel.history(limit=10):
        if msg.author == bot.user and msg.embeds and "Verification" in msg.embeds[0].title:
            return
    
    embed = discord.Embed(
        title="üîê CSR Verification",
        description="Welcome! Click below to verify.\n\n**You'll need:**\n‚Ä¢ Captcha\n‚Ä¢ Roblox User ID\n‚Ä¢ Screenshot (members only)",
        color=discord.Color.blue()
    )
    embed.set_thumbnail(url=GUILD_IMAGE)
    await channel.send(embed=embed, view=VerificationStartView())

# --- MESSAGE HANDLER ---
@bot.event
async def on_message(message):
    if message.author.bot:
        return
    
    # AI Moderation (LESS AGGRESSIVE)
    if CHAT_FILTER_ENABLED:
        flagged_by_regex = BAD_WORDS_REGEX and BAD_WORDS_REGEX.search(message.content.lower())
        flagged_by_ai, ai_reason = await check_message_with_ai(message.content) if AI_MODERATION_ENABLED else (False, None)
        
        if flagged_by_regex or flagged_by_ai:
            try:
                await message.delete()
                
                MODERATION_STATS["total_messages_deleted"] += 1
                if flagged_by_regex:
                    MODERATION_STATS["regex_catches"] += 1
                if flagged_by_ai:
                    MODERATION_STATS["ai_catches"] += 1
                save_json(MODERATION_STATS_FILE, MODERATION_STATS)
                
                modlog = bot.get_channel(MODLOG_CHANNEL_ID)
                detection = "Bad word" if flagged_by_regex else ai_reason
                
                embed = discord.Embed(
                    title="‚ö†Ô∏è Message Deleted",
                    description=f"**User:** {message.author.mention}\n**Channel:** <#{message.channel.id}>\n**Detection:** {detection}",
                    color=discord.Color.red(),
                    timestamp=datetime.datetime.utcnow()
                )
                embed.add_field(name="Content", value=f"`{message.content[:200]}`", inline=False)
                embed.set_footer(text=f"ID: {message.author.id}")
                
                await modlog.send(embed=embed)
                
                await message.channel.send(f"{message.author.mention}, message removed. Keep it respectful! üõ°Ô∏è", delete_after=7)
            except Exception as e:
                print(f"Moderation error: {e}")
    
    # Command shortcuts (csr help = /help)
    if message.content.lower().startswith("csr "):
        command_text = message.content[4:].strip().lower()
        
        # Map common commands
        command_shortcuts = {
            'help': 'help',
            'settings': 'settings',
            'wikiinfo': 'wikiinfo',
            'aboutthisbot': 'aboutthisbot',
            'about': 'aboutthisbot',
            'info': 'aboutthisbot'
        }
        
        # Check if it's a command shortcut
        if command_text in command_shortcuts:
            # Simulate the slash command
            ctx = await bot.get_context(message)
            command_name = command_shortcuts[command_text]
            command = bot.tree.get_command(command_name)
            
            if command:
                try:
                    # Create a fake interaction for the command
                    await message.reply(f"üîó Use `/{command_name}` instead! (Command shortcuts coming soon)", mention_author=False)
                except:
                    pass
            return
    
    # AI Chat (when mentioned or "csr" at start)
    bot_mentioned = bot.user in message.mentions or message.content.lower().startswith("csr ")
    
    if bot_mentioned:
        async with message.channel.typing():
            clean_msg = message.content
            for mention in message.mentions:
                clean_msg = clean_msg.replace(f"<@{mention.id}>", "")
            clean_msg = re.sub(r"^csr\s+", "", clean_msg, flags=re.IGNORECASE).strip()
            
            if clean_msg:
                response, source_type, needs_embed = await chat_with_ai(clean_msg, message.author.id, message.channel.id)
                user_lang = get_user_language(message.author.id)
                
                # If wiki result, make SBOR-style embed
                if needs_embed and source_type:
                    if isinstance(response, dict):
                        if source_type == 'sbor':
                            title = await translate_text("üìö SBOR Answer", user_lang)
                        else:
                            title = await translate_text("üçé Blox Fruits Answer", user_lang)
                        
                        embed = discord.Embed(title=title, color=discord.Color.blue())
                        
                        translated_content = await translate_text(response['content'][:500], user_lang)
                        embed.add_field(name=response['title'], value=translated_content, inline=False)
                        
                        if response.get('image'):
                            embed.set_thumbnail(url=response['image'])
                        
                        view_wiki_text = await translate_text("View on Wiki", user_lang)
                        full_info_text = await translate_text("üîó Full Info", user_lang)
                        embed.add_field(name=full_info_text, value=f"[{view_wiki_text}]({response['url']})", inline=False)
                        
                        await message.reply(embed=embed, mention_author=False)
                    else:
                        await message.reply(response, mention_author=False)
                else:
                    # Casual chat - no embed (already translated)
                    await message.reply(response, mention_author=False)
    
    await bot.process_commands(message)

# --- MEMBER COUNT TRACKER ---
async def update_permanent_message():
    await bot.wait_until_ready()
    channel = bot.get_channel(CHANNEL_ID)
    if not channel:
        return

    message = None
    async for msg in channel.history(limit=20):
        if msg.author == bot.user and msg.embeds and "Member Count" in msg.embeds[0].title:
            message = msg
            break
    
    if not message:
        message = await channel.send("Starting...")

    last_count = None
    while True:
        try:
            count = await get_member_count(GROUP_ID)
            if count != last_count:
                embed = discord.Embed(
                    title="üåü Roblox Community Live Member Count",
                    description="Tracking CSR Roblox Group\n\nüü¢ _Updates every 5 minutes_",
                    color=discord.Color.gold()
                )
                embed.set_thumbnail(url=GUILD_IMAGE)
                embed.add_field(name="üë• Total Members", value=f"**`{count}`**", inline=False)
                
                now = datetime.datetime.utcnow()
                embed.set_footer(text=f"Last updated: {now.strftime('%Y-%m-%d %H:%M UTC')}")
                await message.edit(content="", embed=embed)
                last_count = count
        except Exception as e:
            print(f"Member count error: {e}")
        
        await asyncio.sleep(UPDATE_INTERVAL)

# --- WELCOME ---
@bot.event
async def on_member_join(member):
    embed = discord.Embed(
        title="üéÆ Welcome to CSR!",
        description=f"Hey {member.mention}! Let's get you started! üî•",
        color=discord.Color.blue()
    )
    embed.set_thumbnail(url=GUILD_IMAGE)
    embed.add_field(name="üìã Step 1: Verify", value=f"Go to <#{VERIFICATION_CHANNEL_ID}> and click **Get Verified**!", inline=False)
    embed.add_field(name="‚ùì Need Help?", value=f"Ask in <#{HELP_CHANNEL_ID}>!", inline=False)
    embed.add_field(name="üéØ What We Offer", value="üè¶ Guild Bank\n‚öîÔ∏è Grinding parties\nüéÆ Multi-game support\nüéâ Events & giveaways", inline=False)
    embed.set_footer(text=f"CSR Bot v{BOT_VERSION}")
    
    try:
        await member.send(embed=embed)
    except:
        pass

# --- DAILY CHECK ---
async def daily_check():
    await bot.wait_until_ready()
    channel = bot.get_channel(DAILYCHECKS)
    if not channel:
        return

    while True:
        now = datetime.datetime.utcnow()
        target = now.replace(hour=14, minute=0, second=0, microsecond=0)
        if now > target:
            target += datetime.timedelta(days=1)
        
        await asyncio.sleep((target - now).total_seconds())

        try:
            embed = discord.Embed(
                title="üìã CSR Daily Check",
                description=f"React with {CSR_EMOJI} to show you're active!\n\n**Time:** 7:30 PM IST | 2:00 PM UTC",
                color=discord.Color.blue()
            )
            embed.set_thumbnail(url=GUILD_IMAGE)
            msg = await channel.send("@everyone", embed=embed)
            await msg.add_reaction(CSR_EMOJI)
        except Exception as e:
            print(f"Daily check error: {e}")
        
        await asyncio.sleep(86400)

# --- SLASH COMMANDS ---
@bot.tree.command(name="settings", description="‚öôÔ∏è Configure your preferences (language, timezone)")
async def settings(interaction: discord.Interaction):
    current_lang = get_user_language(interaction.user.id)
    current_tz = get_user_timezone(interaction.user.id)
    
    view = SettingsView(interaction.user.id)
    
    embed = discord.Embed(
        title="‚öôÔ∏è Your Settings",
        description=(
            f"**üåç Language:** {SUPPORTED_LANGUAGES.get(current_lang, 'üá∫üá∏ English')}\n"
            f"**‚è∞ Timezone:** {SUPPORTED_TIMEZONES.get(current_tz, 'UTC')}\n\n"
            f"Click the buttons below to change:"
        ),
        color=discord.Color.blue()
    )
    
    await interaction.response.send_message(embed=embed, view=view, ephemeral=True)

@bot.tree.command(name="forcefetch", description="Manually fetch ALL wiki/YouTube data (Admin only)")
async def forcefetch(interaction: discord.Interaction):
    if not admin_only(interaction):
        await interaction.response.send_message("‚ùå Admin only!", ephemeral=True)
        return
    
    await interaction.response.defer(ephemeral=True)
    await interaction.followup.send("üîÑ Starting FULL fetch (this will take 5-10 minutes)...\n‚è±Ô∏è Fetching ALL pages from wikis...")
    
    # Fetch ALL pages (no limit)
    sbor_pages = await fetch_wiki_pages(SBOR_WIKI_URL, "SBOR", SBOR_WIKI_DATA.get('pages', {}))
    SBOR_WIKI_DATA['pages'] = sbor_pages
    SBOR_WIKI_DATA['last_update'] = datetime.datetime.utcnow().isoformat()
    save_json(SBOR_WIKI_FILE, SBOR_WIKI_DATA)
    
    await asyncio.sleep(2)
    
    blox_pages = await fetch_wiki_pages(BLOXFRUITS_WIKI_URL, "Blox Fruits", BLOXFRUITS_WIKI_DATA.get('pages', {}))
    BLOXFRUITS_WIKI_DATA['pages'] = blox_pages
    BLOXFRUITS_WIKI_DATA['last_update'] = datetime.datetime.utcnow().isoformat()
    save_json(BLOXFRUITS_WIKI_FILE, BLOXFRUITS_WIKI_DATA)
    
    await asyncio.sleep(2)
    
    youtube_vids = await fetch_youtube_channel()
    YOUTUBE_DATA['videos'] = youtube_vids
    YOUTUBE_DATA['last_update'] = datetime.datetime.utcnow().isoformat()
    save_json(YOUTUBE_DATA_FILE, YOUTUBE_DATA)
    
    formatted_time = format_time_for_user(datetime.datetime.utcnow(), interaction.user.id)
    
    await interaction.followup.send(
        f"‚úÖ **Fetch Complete!**\n"
        f"üìö SBOR: {len(SBOR_WIKI_DATA['pages'])} pages\n"
        f"üçé Blox Fruits: {len(BLOXFRUITS_WIKI_DATA['pages'])} pages\n"
        f"üé• YouTube: {len(YOUTUBE_DATA['videos'])} videos\n\n"
        f"üïê Updated: {formatted_time}",
        ephemeral=True
    )

@bot.tree.command(name="modstats", description="View moderation statistics (Staff only)")
async def modstats(interaction: discord.Interaction):
    if not staff_or_admin(interaction.user):
        await interaction.response.send_message("‚ùå Staff only!", ephemeral=True)
        return
    
    stats = MODERATION_STATS
    last_reset = stats.get('last_reset', 'Unknown')
    if last_reset != 'Unknown':
        reset_dt = datetime.datetime.fromisoformat(last_reset)
        last_reset = format_time_for_user(reset_dt, interaction.user.id)
    
    embed = discord.Embed(title="üìä Moderation Statistics", color=discord.Color.blue())
    embed.add_field(name="üóëÔ∏è Total Deleted", value=f"**{stats['total_messages_deleted']}** messages", inline=True)
    embed.add_field(name="üìù Regex Catches", value=f"**{stats['regex_catches']}**", inline=True)
    embed.add_field(name="ü§ñ AI Catches", value=f"**{stats['ai_catches']}**", inline=True)
    
    if stats['total_messages_deleted'] > 0:
        ai_percentage = (stats['ai_catches'] / stats['total_messages_deleted']) * 100
        embed.add_field(name="üìà AI Effectiveness", value=f"**{ai_percentage:.1f}%**", inline=False)
    
    embed.set_footer(text=f"Since: {last_reset}")
    await interaction.response.send_message(embed=embed, ephemeral=True)

@bot.tree.command(name="resetmodstats", description="Reset moderation statistics (Admin only)")
async def resetmodstats(interaction: discord.Interaction):
    if not admin_only(interaction):
        await interaction.response.send_message("‚ùå Admin only!", ephemeral=True)
        return
    
    MODERATION_STATS["total_messages_deleted"] = 0
    MODERATION_STATS["regex_catches"] = 0
    MODERATION_STATS["ai_catches"] = 0
    MODERATION_STATS["last_reset"] = datetime.datetime.utcnow().isoformat()
    save_json(MODERATION_STATS_FILE, MODERATION_STATS)
    
    await interaction.response.send_message("‚úÖ Stats reset!", ephemeral=True)

@bot.tree.command(name="addfaq", description="Add FAQ (Staff only)")
async def addfaq(interaction: discord.Interaction, question: str, answer: str, keywords: str):
    if not staff_or_admin(interaction.user):
        await interaction.response.send_message("‚ùå Staff only!", ephemeral=True)
        return
    
    keyword_list = [k.strip().lower() for k in keywords.split(',')]
    new_faq = {"id": GUILD_FAQS['next_id'], "question": question, "answer": answer, "keywords": keyword_list}
    
    GUILD_FAQS['faqs'].append(new_faq)
    GUILD_FAQS['next_id'] += 1
    save_json(GUILD_FAQS_FILE, GUILD_FAQS)
    
    await interaction.response.send_message(f"‚úÖ FAQ #{new_faq['id']} added!", ephemeral=True)

@bot.tree.command(name="listfaqs", description="List all FAQs (Staff only)")
async def listfaqs(interaction: discord.Interaction):
    if not staff_or_admin(interaction.user):
        await interaction.response.send_message("‚ùå Staff only!", ephemeral=True)
        return
    
    if not GUILD_FAQS['faqs']:
        await interaction.response.send_message("No FAQs yet!", ephemeral=True)
        return
    
    embed = discord.Embed(title="üí° Guild FAQs", color=discord.Color.blue())
    for faq in GUILD_FAQS['faqs']:
        embed.add_field(name=f"#{faq['id']}: {faq['question']}", value=f"{faq['answer'][:100]}...", inline=False)
    
    await interaction.response.send_message(embed=embed, ephemeral=True)

@bot.tree.command(name="removefaq", description="Remove FAQ (Staff only)")
async def removefaq(interaction: discord.Interaction, faq_id: int):
    if not staff_or_admin(interaction.user):
        await interaction.response.send_message("‚ùå Staff only!", ephemeral=True)
        return
    
    for i, faq in enumerate(GUILD_FAQS['faqs']):
        if faq['id'] == faq_id:
            removed = GUILD_FAQS['faqs'].pop(i)
            save_json(GUILD_FAQS_FILE, GUILD_FAQS)
            await interaction.response.send_message(f"‚úÖ Removed FAQ #{faq_id}", ephemeral=True)
            return
    
    await interaction.response.send_message(f"‚ùå FAQ #{faq_id} not found!", ephemeral=True)

@bot.tree.command(name="wikiinfo", description="Show knowledge base stats")
async def wikiinfo(interaction: discord.Interaction):
    embed = discord.Embed(title="üìä Knowledge Base Stats", color=discord.Color.green())
    
    sbor_update = SBOR_WIKI_DATA.get('last_update')
    blox_update = BLOXFRUITS_WIKI_DATA.get('last_update')
    yt_update = YOUTUBE_DATA.get('last_update')
    
    if sbor_update:
        sbor_dt = datetime.datetime.fromisoformat(sbor_update)
        sbor_time = format_time_for_user(sbor_dt, interaction.user.id)
    else:
        sbor_time = 'Never'
    
    if blox_update:
        blox_dt = datetime.datetime.fromisoformat(blox_update)
        blox_time = format_time_for_user(blox_dt, interaction.user.id)
    else:
        blox_time = 'Never'
    
    if yt_update:
        yt_dt = datetime.datetime.fromisoformat(yt_update)
        yt_time = format_time_for_user(yt_dt, interaction.user.id)
    else:
        yt_time = 'Never'
    
    embed.add_field(name="üìö SBOR Wiki", value=f"{len(SBOR_WIKI_DATA['pages'])} pages\nLast: {sbor_time}", inline=True)
    embed.add_field(name="üçé Blox Fruits", value=f"{len(BLOXFRUITS_WIKI_DATA['pages'])} pages\nLast: {blox_time}", inline=True)
    embed.add_field(name="üé• YouTube", value=f"{len(YOUTUBE_DATA['videos'])} videos\nLast: {yt_time}", inline=True)
    embed.add_field(name="üí° FAQs", value=f"{len(GUILD_FAQS['faqs'])} FAQs", inline=True)
    embed.add_field(name="üåç Languages", value=f"{len(SUPPORTED_LANGUAGES)} supported", inline=True)
    embed.add_field(name="‚è∞ Timezones", value=f"{len(SUPPORTED_TIMEZONES)} supported", inline=True)
    
    embed.set_footer(text="Auto-updates weekly ‚Ä¢ Use /forcefetch for manual update")
    await interaction.response.send_message(embed=embed)

@bot.tree.command(name="setupverify", description="Setup verification (Admin only)")
async def setupverify(interaction: discord.Interaction):
    if not admin_only(interaction):
        await interaction.response.send_message("‚ùå Admin only!", ephemeral=True)
        return
    await setup_verification_channel()
    await interaction.response.send_message("‚úÖ Posted!", ephemeral=True)

@bot.tree.command(name="chatfilter", description="Toggle chat filter (Staff only)")
async def chatfilter(interaction: discord.Interaction, state: str):
    if not staff_or_admin(interaction.user):
        await interaction.response.send_message("‚ùå Staff only!", ephemeral=True)
        return
    
    global CHAT_FILTER_ENABLED
    if state.lower() == "on":
        CHAT_FILTER_ENABLED = True
        await interaction.response.send_message("‚úÖ Filter enabled", ephemeral=True)
    elif state.lower() == "off":
        CHAT_FILTER_ENABLED = False
        await interaction.response.send_message("‚ö†Ô∏è Filter disabled", ephemeral=True)

@bot.tree.command(name="aimod", description="Toggle AI moderation (Staff only)")
async def aimod(interaction: discord.Interaction, state: str):
    if not staff_or_admin(interaction.user):
        await interaction.response.send_message("‚ùå Staff only!", ephemeral=True)
        return
    
    global AI_MODERATION_ENABLED
    if state.lower() == "on":
        if not HF_TOKEN:
            await interaction.response.send_message("‚ö†Ô∏è No HF_TOKEN! Add to .env", ephemeral=True)
            return
        AI_MODERATION_ENABLED = True
        await interaction.response.send_message("‚úÖ AI mod enabled (Less aggressive - only severe toxicity)", ephemeral=True)
    elif state.lower() == "off":
        AI_MODERATION_ENABLED = False
        await interaction.response.send_message("‚ö†Ô∏è AI mod disabled", ephemeral=True)

@bot.tree.command(name="aboutthisbot", description="Bot information")
async def aboutthisbot(interaction: discord.Interaction):
    embed = discord.Embed(title="ü§ñ CSR Bot v3.2.0", description="Your ELITE guild companion! üî•", color=discord.Color.blue())
    embed.add_field(name="üë®‚Äçüíª Creator", value=BOT_AUTHOR, inline=True)
    embed.add_field(name="üìÖ Created", value=BOT_CREATED, inline=True)
    embed.add_field(name="üî¢ Version", value=BOT_VERSION, inline=True)
    embed.add_field(name="‚ú® Latest", value=BOT_UPDATE, inline=False)
    embed.add_field(name="üß† Features", value="‚Ä¢ Real AI moderation (less aggressive)\n‚Ä¢ Multi-language (20 languages)\n‚Ä¢ Timezone support\n‚Ä¢ Smart game detection\n‚Ä¢ Command shortcuts (csr help)\n‚Ä¢ Wiki fetcher (ALL pages)\n‚Ä¢ SBOR-style embeds", inline=False)
    await interaction.response.send_message(embed=embed)

@bot.tree.command(name="help", description="Show all commands")
async def help_command(interaction: discord.Interaction):
    embed = discord.Embed(title="üõ†Ô∏è CSR Bot Commands", color=discord.Color.green())
    embed.add_field(name="üí¨ Chat", value="Say 'CSR' or mention me to chat!\nüí° Try: `csr help` or `csr settings`", inline=False)
    embed.add_field(name="/settings", value="‚öôÔ∏è Language & timezone", inline=False)
    embed.add_field(name="/aboutthisbot", value="Bot info", inline=False)
    embed.add_field(name="/wikiinfo", value="Knowledge base stats", inline=False)
    embed.add_field(name="/suggestions <msg>", value="Send suggestion", inline=False)
    
    if staff_or_admin(interaction.user):
        embed.add_field(name="\n**üõ°Ô∏è Staff Commands**", value="_ _", inline=False)
        embed.add_field(name="/forcefetch", value="Fetch ALL wiki pages", inline=False)
        embed.add_field(name="/addfaq, /listfaqs, /removefaq", value="Manage FAQs", inline=False)
        embed.add_field(name="/modstats, /resetmodstats", value="Mod statistics", inline=False)
        embed.add_field(name="/setupverify", value="Post verification", inline=False)
        embed.add_field(name="/kick, /ban, /unban, /mute, /unmute", value="Moderation", inline=False)
        embed.add_field(name="/addroles, /removeroles", value="Role management", inline=False)
        embed.add_field(name="/chatfilter, /aimod", value="Toggle filters", inline=False)
        embed.add_field(name="/announcement", value="Send announcement", inline=False)
    
    embed.set_footer(text=f"CSR Bot v{BOT_VERSION} ‚Ä¢ Made by {BOT_AUTHOR}")
    await interaction.response.send_message(embed=embed)

@bot.tree.command(name="kick", description="Kick member (Staff only)")
async def kick(interaction: discord.Interaction, member: discord.Member, reason: str):
    if not staff_or_admin(interaction.user):
        await interaction.response.send_message("‚ùå No permission", ephemeral=True)
        return
    try:
        await member.kick(reason=reason)
        await interaction.response.send_message(f"‚úÖ Kicked {member.mention}", ephemeral=True)
    except Exception as e:
        await interaction.response.send_message(f"‚ùå Error: {e}", ephemeral=True)

@bot.tree.command(name="ban", description="Ban member (Staff only)")
async def ban(interaction: discord.Interaction, member: discord.Member, reason: str):
    if not staff_or_admin(interaction.user):
        await interaction.response.send_message("‚ùå No permission", ephemeral=True)
        return
    try:
        await member.ban(reason=reason)
        await interaction.response.send_message(f"‚úÖ Banned {member.mention}", ephemeral=True)
    except Exception as e:
        await interaction.response.send_message(f"‚ùå Error: {e}", ephemeral=True)

@bot.tree.command(name="unban", description="Unban user (Staff only)")
async def unban(interaction: discord.Interaction, user: discord.User):
    if not staff_or_admin(interaction.user):
        await interaction.response.send_message("‚ùå No permission", ephemeral=True)
        return
    try:
        await interaction.guild.unban(user)
        await interaction.response.send_message(f"‚úÖ Unbanned {user.mention}", ephemeral=True)
    except Exception as e:
        await interaction.response.send_message(f"‚ùå Error: {e}", ephemeral=True)

@bot.tree.command(name="mute", description="Mute member (Staff only)")
async def mute(interaction: discord.Interaction, member: discord.Member, reason: str):
    if not staff_or_admin(interaction.user):
        await interaction.response.send_message("‚ùå No permission", ephemeral=True)
        return
    
    mute_role = interaction.guild.get_role(MUTED_ROLE_ID)
    if not mute_role:
        await interaction.response.send_message("‚ùå Muted role not found!", ephemeral=True)
        return
    
    try:
        await member.add_roles(mute_role, reason=reason)
        await interaction.response.send_message(f"‚úÖ Muted {member.mention}", ephemeral=True)
    except Exception as e:
        await interaction.response.send_message(f"‚ùå Error: {e}", ephemeral=True)

@bot.tree.command(name="unmute", description="Unmute member (Staff only)")
async def unmute(interaction: discord.Interaction, member: discord.Member):
    if not staff_or_admin(interaction.user):
        await interaction.response.send_message("‚ùå No permission", ephemeral=True)
        return
    
    mute_role = interaction.guild.get_role(MUTED_ROLE_ID)
    if not mute_role:
        await interaction.response.send_message("‚ùå Muted role not found!", ephemeral=True)
        return
    
    try:
        await member.remove_roles(mute_role)
        await interaction.response.send_message(f"‚úÖ Unmuted {member.mention}", ephemeral=True)
    except Exception as e:
        await interaction.response.send_message(f"‚ùå Error: {e}", ephemeral=True)

@bot.tree.command(name="announcement", description="Send announcement (Staff only)")
async def announcement(interaction: discord.Interaction, channel: discord.TextChannel, message: str):
    if not staff_or_admin(interaction.user):
        await interaction.response.send_message("‚ùå No permission", ephemeral=True)
        return
    try:
        await channel.send(message)
        await interaction.response.send_message(f"‚úÖ Sent to {channel.mention}", ephemeral=True)
    except Exception as e:
        await interaction.response.send_message(f"‚ùå Error: {e}", ephemeral=True)

@bot.tree.command(name="suggestions", description="Send anonymous suggestion")
async def suggestions(interaction: discord.Interaction, message: str):
    channel = interaction.guild.get_channel(MODLOG_CHANNEL_ID)
    staff_role = interaction.guild.get_role(CSR_STAFF_ROLE_ID)
    
    embed = discord.Embed(title="üí° New Suggestion", description=message, color=discord.Color.blue(), timestamp=datetime.datetime.utcnow())
    embed.set_footer(text=f"From: {interaction.user.name}")
    
    await channel.send(f"{staff_role.mention}", embed=embed)
    await interaction.response.send_message("‚úÖ Suggestion sent!", ephemeral=True)

@bot.tree.command(name="addroles", description="Add roles (Staff only)")
async def addroles(interaction: discord.Interaction, member: discord.Member, roles: str):
    if not staff_or_admin(interaction.user):
        await interaction.response.send_message("‚ùå Staff only!", ephemeral=True)
        return
    
    role_list = [r.strip() for r in roles.split(',')]
    added_roles = []
    
    for role_input in role_list:
        role = None
        if role_input.startswith('<@&'):
            role = interaction.guild.get_role(int(role_input[3:-1]))
        elif role_input.isdigit():
            role = interaction.guild.get_role(int(role_input))
        else:
            role = discord.utils.get(interaction.guild.roles, name=role_input)
        
        if role and role not in member.roles:
            try:
                await member.add_roles(role)
                added_roles.append(role.name)
            except:
                pass
    
    if added_roles:
        await interaction.response.send_message(f"‚úÖ Added: {', '.join(added_roles)}", ephemeral=True)
    else:
        await interaction.response.send_message("‚ùå No roles added", ephemeral=True)

@bot.tree.command(name="removeroles", description="Remove roles (Staff only)")
async def removeroles(interaction: discord.Interaction, member: discord.Member, roles: str):
    if not staff_or_admin(interaction.user):
        await interaction.response.send_message("‚ùå Staff only!", ephemeral=True)
        return
    
    role_list = [r.strip() for r in roles.split(',')]
    removed_roles = []
    
    for role_input in role_list:
        role = None
        if role_input.startswith('<@&'):
            role = interaction.guild.get_role(int(role_input[3:-1]))
        elif role_input.isdigit():
            role = interaction.guild.get_role(int(role_input))
        else:
            role = discord.utils.get(interaction.guild.roles, name=role_input)
        
        if role and role in member.roles:
            try:
                await member.remove_roles(role)
                removed_roles.append(role.name)
            except:
                pass
    
    if removed_roles:
        await interaction.response.send_message(f"‚úÖ Removed: {', '.join(removed_roles)}", ephemeral=True)
    else:
        await interaction.response.send_message("‚ùå No roles removed", ephemeral=True)

# --- RUN BOT ---
if __name__ == "__main__":
    bot.run(TOKEN)
